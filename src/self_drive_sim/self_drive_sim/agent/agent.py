from self_drive_sim.agent.interfaces import Observation, Info, MapInfo
from self_drive_sim.simulation.floor_map import FloorMap

import os
import math
import numpy as np
import itertools
from dataclasses import dataclass, field
from scipy.ndimage import distance_transform_edt, zoom

OCCUPANCY_GRID_MAP0 = """
1111111111111111111111111111111111111111
1111111111111111111111111111111111111111
1100000000000000000000001000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000001000000000000011
1111111111111111111111111000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1100000000000000000000000000000000000011
1111111111111111111111111111111111111111
1111111111111111111111111111111111111111
"""

OCCUPANCY_GRID_MAP1 = """
11111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111
11111100001000000000001111111000000000000000000011
11111100001000000000001111111000000000000000000011
11111100001000000000001111111000000000000000000011
11111100001000000000000001000000000000000000000011
11111100001000000000000001000000000000000000000011
11111100001000000000000001000000000000000000000011
11110000001000000000000001000000000000000000000011
11110000000000000000000001000000000000000000011111
11110000000000000000000001000000000000000000011111
11110000000000000000000001000000000000000000011111
11110000000000000000000001000000000000000000011111
11110000001111111111111111000000000000000000011111
11110000000000000000000001000000000000000000011111
11110000000000000000000000000000000000000000011111
11110000000000000000000000000000000000000000011111
11110000000000000000000000000000000000000000011111
11110000000000000000000000000000000000000000011111
11111000000000000000000001111111111111111111111111
11000000000000000000000000000000000001111111111111
11000000000000000000000000000000000001111111111111
11000000000000000000000000000000000001111111111111
11000000000000000000000000000000000000000000000011
11000000000000000000000001000000000000000000000011
11000000000000000000000001000000000000000000000011
11000000000000000000000001000000000000000000000011
11000000000000000000000001000000000000000000000011
11000000000000000000000001000000000000000000000011
11000000000000000000000001000000000000000000000011
11000000000000000000000001000000000000000000000011
11000000000000000000000001000000000000000000000011
11000000000000000000000001111000000000000000000011
11000000000000000000000001111000000000000000000011
11000000000000000000000001111000000000000000000011
11000000000000000000000001111000000000000000000011
11000000000000000000000001111000000000000000000011
11000000000000000000000001111000000000000000000011
11000000000000000000000001111000000000000000000011
11000000000000000000000001111000000000000000000011
11000000000000000000000001111000000000000000000011
11111111111111110000000011111111111111111111111111
11000000000000000000000000000000000000000000011111
11000000000000000000000000000000000000000000011111
11000000000000000000000000000000000000000000011111
11000000000000000000000000000000000000000000011111
11110000000000000000000000000000000000000000011111
11110000000000000000000000000000000000000000011111
11111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111
"""

OCCUPANCY_GRID_MAP2 = """
111111111111111111111111111111111111111111111111111111111000000000000000000
111111111111111111111111111111111111111111111111111111111000000000000000000
110000000000000000000000111110000001000000000000000000011000000000000000000
110000000000000000000000111110000001000000000000000000011000000000000000000
110000000000000000000000111110000001000000000000000000011000000000000000000
110000000000000000000000111110000001000000000000000000011000000000000000000
110000000000000000000000111110000000000000000000000000011000000000000000000
110000000000000000000000111110000000000000000000000000011000000000000000000
110000000000000000000000111110000000000000000000000000011000000000000000000
110000000000000000000000111110000000000000000000000000011000000000000000000
110000000000000000000000000010000001000000000000000000011000000000000000000
110000000000000000000000000000000001000000000000000000011000000000000000000
110000000000000000000000000000000001000000000000000000011111111111111111111
110000000000000000000000000000000001000000000000000000011111111111111111111
110000000000000000000000000000000001111111111111111111111111111111111111111
110000000000000000000000000010000000000000000000011111111111111111111111111
111111111111111111111111111110000000000000000000011111111111111111111111111
111111111111000000000000000010000000000000000000011111111111111111111111111
111111111111000000000000000000000000000000000000011111111111111111111111111
111111111111000000000000000000000000000000000000000000000000000000000011111
111111111111000000000000000000000000000000000000000000000000000000000011111
111111111111000000000000000000000000000000000000000000000000000000000011111
111111111111000000000000000010000000000000000000000000000000000000000011111
111000000001000000000000000010000000000000000000000000000000000000000011111
111000000001000000000000000010000000000000000000000000000000000000000011111
111000000001000000000000000010000000000000000000000000000000000000000011111
111000000001000000000000000010000000000000000000000000000000000000000011111
111000000001000000000000000010000000000000000000000000000000000000000011111
111000000001000000000000000010000000000000000000000000000000000000000011111
111000000001000000000000000010000000000000000000000000000000000000000011111
111000000001000000000000000010000000000000000000011111111111111111111111111
111000000001000000000000000010000000000000000000011111111111111111111111111
111000000001000000000000000010000000000000000000011111111111111111111111111
111000000001000000000000000010000000000000000000011111111111111111111111111
111110000111111111111111111110000000000000000000000000000000000000000001111
111100000000000000000000000010000000000000000000000000000000000000000001111
111100000000000000000000000000000000000000000000000000000000000000000001111
111100000000000000000000000000000000000000000000000000000000000000000001111
111100000000000000000000000000000000000000000000000000000000000000000001111
111100000000000000000000000000000000000000000000000000000000000000000001111
111100000000000000000000000010000000000000000000000000000000000000000001111
111100000000000000000000000010000000000000000000000000000000000000000001111
111100000000000000000000000010000000000000000000000000000000000000000001111
111100000000000000000000000010000000000000000000000000000000000000000001111
111100000000000000000000000010000000000000000000000000000000000000000000011
111100000000000000000000000010000000000000000000000000000000000000000000011
111100000000000000000000000010000000000000000000000000000000000000000000011
111100000000000000000000000010000000000000000000000000000000000000000000011
111100000000000000000000000010000000000000000000000000000000000000000000011
111100000000000000000000000010000000000000000000000000000000000000000000011
111111111111111111111111111110000000000000000000000000000000000000000000011
111111111111111111111111111110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000111111100000000111111111111110000000011111111111
000000000000000000000000000111100000000000000000000000000000000000000001111
000000000000000000000000000111100000000000000000000000000000000000000001111
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000110000000000000000000000000000000000000000000011
000000000000000000000000000111100000000000000000000000000000000000000001111
000000000000000000000000000111100000000000000000000000000000000000000001111
000000000000000000000000000111111111111111111111111111111111111111111111111
000000000000000000000000000111111111111111111111111111111111111111111111111
"""

OCCUPANCY_GRID_MAP3 = """
1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
1100000000000000000000000000000000111111111111111100000000111100000000000000001111111100000000000011
1100000000000000000000000000000000000000000000000000000000111100000000000000001111111100000000000011
1100000000000000000000000000000000000000000000000000000000111100000000000000001111111100000000000011
1100000000000000000000000000000000000000000000000000000000111100000000000000001111111100000000000011
1100000001000000000100000000000000000000000000000000000000111100000000000000001111111100000000000011
1100000001000000000100000000000000000000000000000000000000111100000000000000001111111100000000000011
1100000001111111111111111111111111111111111111111100000000111100000000000000001111111100000000000011
1100000001111111111111111111111111111111111111111100000000111100000000000000001111111100000000000011
1100000001111111111111111111111111111111111111111100000000111111111111110000111111111100000000000011
1100000000000100000000000000000011111111111111111000000000000000000000000000000000000100000000000011
1100000000000000000000000000000011111111111111111000000000000000000000000000000000000100000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011
1100000000000100000000111110000000000000000000000000000000000000000000000000000000000000000000000011
1111111111111100000000111110000000000000000000000000000000111111111111111111100000000000000000000011
1100000000000100000000111110000000000000000000000000000000100000000000000000100000000100000000000011
1100000000000100000000111110000000000000000000000000000000100000000000000000100000000100000000000011
1100000000000100000000111110000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000100000000111110000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000100000000111110000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000100000000111110000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000100000000111110000000000000000000000000000000100000000000000000100000000100000000000011
1100000000000100000000111110000000000000000000000000000000100000000000000000100000000100000000000011
1100000000000100000000111110000000000000000000000000000000100000000000000000100000000100000000000011
1100000000000100000000111110000000000000000000111100000011111111111111111111100000000111111111111111
1100000000000100000000111111111111111111111111111100000010000000000000000000100000000100000000000011
1100000000000100000000111111111111111111111111111100000010000000000000000000000000000000000000000011
1100000000000100000000111111111111111111111111111100000010000000000000000000000000000000000000000011
1100000000000100000000111111111111111111111111111100000010000000000000000000000000000000000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000000000000000000000000011
1100000000000000000000000000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000000000000000000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000000000000000000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000000000000000000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1111111111111100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000100000000000000000000000000100000010000000000000000000100000000100000000000011
1100000000000100000000111111111111111111111100001100000011000011111111111111100000000100000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1111111111111100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000000000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000000000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000000000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000000000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000000000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000000000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000000000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000000000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000000000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000000000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1100000000000100000000100000000000000000100000000000000000100000000000000000100000000100000000000011
1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
"""

all_map_reference_waypoints = {
    0: {
        (0, 1): [(1.2, 2.0), (-1.0, 2.0), (-1.0, -2.0)],
        (0, 3): [(1.2, 2.0), (1.4, -3.0)],

        (1, 0): [(-1.0, -2.0), (-1.0, 2.0), (1.2, 2.0)],
        (1, 3): [(-1.0, -2.0), (-1.0, 2.0), (1.2, 2.0), (1.4, -3.0)],

        (2, 0): [(2.0, 0.0), (1.2, 2.0)],
        (2, 1): [(2.0, 0.0), (1.2, 2.0), (-1.0, 2.0), (-1.0, -2.0)],
    },

    1: {
        (0, 1): [(0.0, -2.0), (-1.6, -3.6), (-2.8, -3.6), (-2.8, -2.9), (-2.8, -2.0)],               
        (0, 2): [(0.0, -2.0), (-1.6, -0.6), (-1.6, 0.1), (-1.6, 0.6), (-2.0, 2.4)],
        (0, 3): [(0.0, -2.0), (-0.6, -0.6), (-0.6, 0.1), (-0.6, 0.6), (0.9, 0.9), (1.0, 3.0)],
        (0, 4): [(0.0, -2.0), (1.0, -0.9), (4.0, -0.9), (4.0, 2.4)],
        (0, 6): [(0.0, -2.0), (0.8, -3.6), (2.8, -4.2)],

        (1, 0): [(-2.8, -2.0), (-2.8, -2.9), (-2.8, -3.6), (-1.6, -3.6), (0.0, -2.0)],
        (1, 2): [(-2.8, -2.0), (-2.8, -2.9), (-2.8, -3.6), (-1.6, -3.6), (-1.6, -0.6), (-1.6, 0.1), (-1.6, 0.6), (-2.0, 2.4)],
        (1, 3): [(-2.8, -2.0), (-2.8, -2.9), (-2.8, -3.6), (-1.6, -3.6), (-0.6, -0.6), (-0.6, 0.1), (-0.6, 0.6), (0.9, 0.9), (1.0, 3.0)],
        (1, 4): [(-2.8, -2.0), (-2.8, -2.9), (-2.8, -3.6), (-1.6, -3.6), (1.0, -0.9), (4.0, -0.9), (4.0, 2.4)],
        (1, 5): [(-2.8, -2.0), (-2.8, -2.9), (-2.8, -3.6), (-1.6, -3.6), (0, -2)],
        (1, 6): [(-2.8, -2.0), (-2.8, -2.9), (-2.8, -3.6), (-1.6, -3.6), (0.8, -3.6), (2.8, -4.2)],
                    
        (2, 0): [(-2.0, 2.4), (-1.6, 0.6), (-1.6, 0.1), (-1.6, -0.6), (0.0, -2.0)],			
        (2, 1): [(-2.0, 2.4), (-1.6, 0.6), (-1.6, 0.1), (-1.6, -0.6), (-1.6, -3.6), (-2.8, -3.6), (-2.8, -2.9), (-2.8, -2.0)],
        (2, 3): [(-2.0, 2.4), (-1.6, 0.6), (-1.6, 0.1), (-1.6, -0.6), (-0.6, -0.6), (-0.6, 0.1), (-0.6, 0.6), (0.9, 0.9), (1.0, 3.0)],
        (2, 4): [(-2.0, 2.4), (-1.6, 0.6), (-1.6, 0.1), (-1.6, -0.6), (4.0, -0.9), (4.0, 2.4)],
        (2, 5): [(-2.0, 2.4), (-1.6, 0.6), (-1.6, 0.1), (-1.6, -0.6), (0, -2)],
        (2, 6): [(-2.0, 2.4), (-1.6, 0.6), (-1.6, 0.1), (-1.6, -0.6), (0.8, -3.6), (2.8, -4.2)],			
            
        (3, 0): [(1.0, 3.0), (0.9, 0.9), (-0.6, 0.6), (-0.6, 0.1), (-0.6, -0.6), (0.0, -2.0)],	
        (3, 1): [(1.0, 3.0), (0.9, 0.9), (-0.6, 0.6), (-0.6, 0.1), (-0.6, -0.6), (-1.6, -3.6), (-2.8, -3.6), (-2.8, -2.9), (-2.8, -2.0)],
        (3, 2): [(1.0, 3.0), (0.9, 0.9), (-0.6, 0.6), (-0.6, 0.1), (-0.6, -0.6), (-1.6, -0.6), (-1.6, 0.1), (-1.6, 0.6), (-2.0, 2.4)],
        (3, 4): [(1.0, 3.0), (0.9, 0.9), (-0.6, 0.6), (-0.6, 0.1), (-0.6, -0.6), (4.0, -0.9), (4.0, 2.4)],
        (3, 5): [(1.0, 3.0), (0.9, 0.9), (-0.6, 0.6), (-0.6, 0.1), (-0.6, -0.6), (0, -2)],
        (3, 6): [(1.0, 3.0), (0.9, 0.9), (-0.6, 0.6), (-0.6, 0.1), (-0.6, -0.6), (0.8, -3.6), (2.8, -4.2)],

        (4, 0): [(4.0, 2.4), (4.0, -0.9), (1.0, -0.9), (0.0, -2.0)],
        (4, 1): [(4.0, 2.4), (4.0, -0.9), (1.0, -0.9), (-1.6, -3.6), (-2.8, -3.6), (-2.8, -2.9), (-2.8, -2.0)],
        (4, 2): [(4.0, 2.4), (4.0, -0.9), (-1.6, -0.6), (-1.6, 0.1), (-1.6, 0.6), (-2.0, 2.4)],
        (4, 3): [(4.0, 2.4), (4.0, -0.9), (-0.6, -0.6), (-0.6, 0.1), (-0.6, 0.6), (0.9, 0.9), (1.0, 3.0)],
        (4, 5): [(4.0, 2.4), (4.0, -0.9), (1.0, -0.9), (0, -2)],
        (4, 6): [(4.0, 2.4), (4.0, -0.9), (1.0, -0.9), (0.8, -3.6), (2.8, -4.2)],

        (5, 0): [(0, -2)],
        (5, 1): [(0, -2), (-1.6, -3.6), (-2.8, -3.6), (-2.8, -2.9), (-2.8, -2.0)],               
        (5, 2): [(0, -2), (-1.6, -0.6), (-1.6, 0.1), (-1.6, 0.6), (-2.0, 2.4)],
        (5, 3): [(0, -2), (-0.6, -0.6), (-0.6, 0.1), (-0.6, 0.6), (0.9, 0.9), (1.0, 3.0)],
        (5, 4): [(0, -2), (1.0, -0.9), (4.0, -0.9), (4.0, 2.4)],
        (5, 6): [(0, -2), (0.8, -3.6), (2.8, -4.2)],
    },

    2: {
        (0, 1): [(4.0, 2.0), (-2.4, 0.6), (-2.4, 5.0)],               
        (0, 2): [(4.0, 2.0), (-3.4, -1.0), (-5.8, -1.0), (-5.8, -0.3), (-5.8, 2.0)],
        (0, 3): [(4.0, 2.0), (-3.4, -1.0), (-4.8, -1.0), (-4.8, -1.7), (-4.8, -3.4), (-4.8, -5.0), (-5.2, -5.2)],
        (0, 4): [(4.0, 2.0), (-3.4, -1.0), (-3.4, -1.7), (-3.4, -2.4), (-1.4, -3.4)],
        (0, 5): [(4.0, 2.0), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.1), (-0.5, -6.1), (-1.1, -6.1)],
        (0, 6): [(4.0, 2.0), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.0)],
        (0, 7): [(4.0, 2.0), (4.6, 3.8), (6.8, 5.4)],
        (0, 8): [(4.0, 2.0), (3, 3)],
        (0, 9): [(4.0, 2.0), (1.0, 3.0), (-0.2, 6.4)],

        (1, 0): [(-2.4, 5.0), (-2.4, 0.6), (4.0, 2.0)],
        (1, 2): [(-2.4, 5.0), (-2.4, 0.6), (-3.4, -1.0), (-5.8, -1.0), (-5.8, -0.3), (-5.8, 2.0)],
        (1, 3): [(-2.4, 5.0), (-2.4, 0.6), (-3.4, -1.0), (-4.8, -1.0), (-4.8, -1.7), (-4.8, -3.4), (-4.8, -5.0), (-5.2, -5.2)],
        (1, 4): [(-2.4, 5.0), (-2.4, 0.6), (-3.4, -1.0), (-3.4, -1.7), (-3.4, -2.4), (-1.4, -3.4)],
        (1, 5): [(-2.4, 5.0), (-2.4, 0.6), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.1), (-0.5, -6.1), (-1.1, -6.1)],
        (1, 6): [(-2.4, 5.0), (-2.4, 0.6), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.0)],
        (1, 7): [(-2.4, 5.0), (-2.4, 0.6), (4.6, 3.8), (6.8, 5.4)],
        (1, 8): [(-2.4, 5.0), (-2.4, 0.6), (3, 3)],
        (1, 9): [(-2.4, 5.0), (-2.4, 0.6), (-0.2, 1.0), (-0.2, 6.4)],
                    
        (2, 0): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (-3.4, -1.0), (4.0, 2.0)],			
        (2, 1): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (-3.4, -1.0), (-2.4, 0.6), (-2.4, 5.0)],
        (2, 3): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (-4.8, -1.0), (-4.8, -1.7), (-4.8, -3.4), (-4.8, -5.0), (-5.2, -5.2)],
        (2, 4): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (-3.4, -1.0), (-3.4, -1.7), (-3.4, -2.4), (-1.4, -3.4)],
        (2, 5): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.1), (-0.5, -6.1), (-1.1, -6.1)],
        (2, 6): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.0)],
        (2, 7): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (-3.4, -1.0), (4.6, 3.8), (6.8, 5.4)],
        (2, 8): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (-3.4, -1.0), (3, 3)],
        (2, 9): [(-5.8, 2.0), (-5.8, -0.3), (-5.8, -1.0), (-3.4, -1.0), (-0.2, 1.0), (-0.2, 6.4)],		
            
        (3, 0): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-4.8, -1.7), (-4.8, -1.0), (-3.4, -1.0), (4.0, 2.0)],
        (3, 1): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-4.8, -1.7), (-4.8, -1.0), (-3.4, -1.0), (-2.4, 0.6), (-2.4, 5.0)],
        (3, 2): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-4.8, -1.7), (-4.8, -1.0), (-5.8, -1.0), (-5.8, -0.3), (-5.8, 2.0)],
        (3, 4): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-3.4, -1.0), (-3.4, -1.7), (-3.4, -2.4), (-1.4, -3.4)],
        (3, 5): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-4.8, -1.7), (-4.8, -1.0), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.1), (-0.5, -6.1), (-1.1, -6.1)],
        (3, 6): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-4.8, -1.7), (-4.8, -1.0), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.0)],
        (3, 7): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-4.8, -1.7), (-4.8, -1.0), (-3.4, -1.0), (4.6, 3.8), (6.8, 5.4)],
        (3, 8): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-4.8, -1.7), (-4.8, -1.0), (-3.4, -1.0), (3, 3)],
        (3, 9): [(-5.2, -5.2), (-4.8, -5.0), (-4.8, -3.4), (-4.8, -1.7), (-4.8, -1.0), (-3.4, -1.0), (-0.2, 1.0), (-0.2, 6.4)],

        (4, 0): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (4.0, 2.0)],
        (4, 1): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (-2.4, 0.6), (-2.4, 5.0)],
        (4, 2): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (-5.8, -1.0), (-5.8, -0.3), (-5.8, 2.0)],
        (4, 3): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (-4.8, -1.0), (-4.8, -1.7), (-4.8, -3.4), (-4.8, -5.0), (-5.2, -5.2)],
        (4, 5): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.1), (-0.5, -6.1), (-1.1, -6.1)],
        (4, 6): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.0)],
        (4, 7): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (4.6, 3.8), (6.8, 5.4)],
        (4, 8): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (3, 3)],
        (4, 9): [(-1.4, -3.4), (-3.4, -2.4), (-3.4, -1.0), (-0.2, 1.0), (-0.2, 6.4)],

        (5, 0): [(-1.1, -6.1), (-0.5, -6.1), (1.0, -6.1), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (4.0, 2.0)],
        (5, 1): [(-1.1, -6.1), (-0.5, -6.1), (1.0, -6.1), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-2.4, 0.6), (-2.4, 5.0)],           
        (5, 2): [(-1.1, -6.1), (-0.5, -6.1), (1.0, -6.1), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-5.8, -1.0), (-5.8, -0.3), (-5.8, 2.0)],
        (5, 3): [(-1.1, -6.1), (-0.5, -6.1), (1.0, -6.1), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-4.8, -1.0), (-4.8, -1.7), (-4.8, -3.4), (-4.8, -5.0), (-5.2, -5.2)],
        (5, 4): [(-1.1, -6.1), (-0.5, -6.1), (1.0, -6.1), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-3.4, -1.0), (-3.4, -1.7), (-3.4, -2.4), (-1.4, -3.4)],
        (5, 6): [(-1.0, -6.1), (1.0, -6.0)],
        (5, 7): [(-1.1, -6.1), (-0.5, -6.1), (1.0, -6.1), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (4.6, 3.8), (6.8, 5.4)],
        (5, 8): [(-1.1, -6.1), (-0.5, -6.1), (1.0, -6.1), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (3, 3)],
        (5, 9): [(-1.1, -6.1), (-0.5, -6.1), (1.0, -6.1), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-0.2, 6.4)],

        (6, 0): [(1.0, -6.0), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (4.0, 2.0)],
        (6, 1): [(1.0, -6.0), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-2.4, 0.6), (-2.4, 5.0)],              
        (6, 2): [(1.0, -6.0), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-5.8, -1.0), (-5.8, -0.3), (-5.8, 2.0)],
        (6, 3): [(1.0, -6.0), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-4.8, -1.0), (-4.8, -1.7), (-4.8, -3.4), (-4.8, -5.0), (-5.2, -5.2)],
        (6, 4): [(1.0, -6.0), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-3.4, -1.0), (-3.4, -1.7), (-3.4, -2.4), (-1.4, -3.4)],
        (6, 5): [(1.0, -6.1), (-0.5, -6.1), (-1.1, -6.1)],
        (6, 7): [(1.0, -6.0), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (4.6, 3.8), (6.8, 5.4)],
        (6, 8): [(1.0, -6.0), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (3, 3)],
        (6, 9): [(1.0, -6.0), (1.0, -4.2), (0.2, -3.0), (0.2, -1.7), (0.2, -1.0), (-0.2, 6.4)],

        (7, 0): [(6.8, 5.4), (4.6, 3.8), (4.0, 2.0)],
        (7, 1): [(6.8, 5.4), (4.6, 3.8), (-2.4, 0.6), (-2.4, 5.0)],                
        (7, 2): [(6.8, 5.4), (4.6, 3.8), (-3.4, -1.0), (-5.8, -1.0), (-5.8, -0.3), (-5.8, 2.0)],
        (7, 3): [(6.8, 5.4), (4.6, 3.8), (-3.4, -1.0), (-4.8, -1.0), (-4.8, -1.7), (-4.8, -3.4), (-4.8, -5.0), (-5.2, -5.2)],
        (7, 4): [(6.8, 5.4), (4.6, 3.8), (-3.4, -1.0), (-3.4, -1.7), (-3.4, -2.4), (-1.4, -3.4)],
        (7, 5): [(6.8, 5.4), (4.6, 3.8), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.1), (-0.5, -6.1), (-1.1, -6.1)],
        (7, 6): [(6.8, 5.4), (4.6, 3.8), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.0)],
        (7, 8): [(6.8, 5.4), (4.6, 3.8), (3, 3)],
        (7, 9): [(6.8, 5.4), (4.6, 3.8), (1, 3), (-0.2, 6.4)],

        (8, 0): [(3, 3), (4.0, 2.0)],
        (8, 1): [(3, 3), (-2.4, 0.6), (-2.4, 5.0)],               
        (8, 2): [(3, 3), (-3.4, -1.0), (-5.8, -1.0), (-5.8, -0.3), (-5.8, 2.0)],
        (8, 3): [(3, 3), (-3.4, -1.0), (-4.8, -1.0), (-4.8, -1.7), (-4.8, -3.4), (-4.8, -5.0), (-5.2, -5.2)],
        (8, 4): [(3, 3), (-3.4, -1.0), (-3.4, -1.7), (-3.4, -2.4), (-1.4, -3.4)],
        (8, 5): [(3, 3), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.1), (-0.5, -6.1), (-1.1, -6.1)],
        (8, 6): [(3, 3), (0.1, -1.0), (0.1, -1.7), (0.1, -3.0), (1.0, -4.2), (1.0, -6.0)],
        (8, 7): [(3, 3), (4.6, 3.8), (6.8, 5.4)],
        (8, 9): [(3, 3), (1, 3), (-0.2, 6.4)],
    },

    3: {
        (0, 1): [(-4.8, -2.2), (-5.2, 0.4),(-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (0, 2): [(-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (0, 3): [(-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (1.6, -6.1), (2.2, -6.8), (2.2, -8.0)],
        (0, 4): [(-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (1.6, -6.1), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7, -9)],
        (0, 5): [(-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (2.0, -6.1), (2.0, -3.4), (6.0, -3.4)],
        (0, 6): [(-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (2.0, -6.1), (2.0, 0.0), (6.0, 0.0)],
        (0, 7): [(-4.8, -2.2), (-5.2, 0.4), (-5.2, 5.8), (2.0, 5.8), (2.0, 3.6), (6.0, 3.6)],
        (0, 8): [(-4.8, -2.2), (-5.2, 0.4), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 7), (-1.8, 8.6), (5.0, 8.6)],
        (0, 9): [(-4.8, -2.2), (-5.2, 0.4), (-5.2, 6.6), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (0,10): [(-4.8, -2.2), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (0,11): [(-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -6.6), (-1.0, -5.0), (-0.2, -2.8)],
        (0,12): [(-4.8, -2.2), (-5.2, 0.4), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 5.4), (-1.8, 4.8), (-1.2, 2.6)],
        (0,13): [(-4.8, -2.2), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (0,14): [(-4.8, -2.2), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (1, 0): [(-7.2, -9.0), (-7.2, -5.0), (-6.9, -4), (-6.9, 0.5), (-5.2, 0.4), (-4.8, -2.2)],
        (1, 2): [(-7.2, -9.0), (-5.2, -9.0), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (1, 3): [(-7.2, -9.0), (-5.2, -9.0), (-5.3, -6.1), (1.6, -6.1), (2.2, -6.8), (2.2, -8.0)],
        (1, 4): [(-7.2, -9.0), (-5.2, -9.0), (-5.3, -6.1), (1.6, -6.1), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (1, 5): [(-7.2, -9.0), (-5.2, -9.0), (-5.3, -6.1), (2.2, -6.8), (2.0, -3.4), (6.0, -3.4)],
        (1, 6): [(-7.2, -9.0), (-5.2, -9.0), (-5.3, -6.1), (2.2, -6.8), (2.0, 0.0), (6.0, 0.0)],
        (1, 7): [(-7.2, -9.0), (-7.2, -5.0), (-6.9, -4.0), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 5.8), (2.0, 5.8), (2.0, 3.6), (6.0, 3.6)],
        (1, 8): [(-7.2, -9.0), (-7.2, -5.0), (-6.9, -4.0), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 7), (-1.8, 8.6), (5.0, 8.6)],
        (1, 9): [(-7.2, -9.0), (-7.2, -5.0), (-6.9, -4.0), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 6.2), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (1,10): [(-7.2, -9.0), (-7.2, -5.0), (-6.9, -4.0), (-6.9, 0.5), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (1,11): [(-7.2, -9.0), (-5.2, -9.0), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -6.6), (-1.0, -5.0), (-0.2, -2.8)],
        (1,12): [(-7.2, -9.0), (-7.2, -5.0), (-6.9, -4.0), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 5.4), (-1.8, 4.8), (-1.2, 2.6)],
        (1,13): [(-7.2, -9.0), (-7.2, -5.0), (-6.9, -4.0), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (1,14): [(-7.2, -9.0), (-7.2, -5.0), (-6.9, -4.0), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (2, 0): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-5.3, -6.1), (-5.2, -9.0), (-7.2, -9.0), (-7.2, -5.0), (-6.9, -4), (-6.9, 0.5), (-5.2, 0.4), (-4.8, -2.2)],
        (2, 1): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-5.3, -6.1), (-5.2, -9.0), (-7.2, -9.0)],
        (2, 3): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (1.6, -6.1), (2.2, -6.8), (2.2, -8.0)],
        (2, 4): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (1.6, -6.1), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (2, 5): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (1.6, -6.1), (2.0, -6.1), (2.0, -3.4), (6.0, -3.4)],
        (2, 6): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (1.6, -6.1), (2.0, -6.1), (2.0, 0.0), (6.0, 0.0)],
        (2, 7): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (1.6, -6.1), (2.0, -6.1), (2.0, 3.6), (6.0, 3.6)],
        (2, 8): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-5.3, -6.1), (-5.2, -9.0), (-7.2, -9.0), (-7.2, -5.0), (-6.9, -4), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 7), (-1.8, 8.6), (5.0, 8.6)],
        (2, 9): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-5.3, -6.1), (-5.2, -9.0), (-7.2, -9.0), (-7.2, -5.0), (-6.9, -4), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 6.6), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (2,10): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-5.3, -6.1), (-5.2, -9.0), (-7.2, -9.0), (-7.2, -5.0), (-6.9, -4), (-6.9, 0.5), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (2,11): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-1.0, -6.6), (-1.0, -5.0), (-0.2, -2.8)],
        (2,12): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-5.3, -6.1), (-5.2, -9.0), (-7.2, -9.0), (-7.2, -5.0), (-6.9, -4), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 5.4), (-1.8, 4.8), (-1.2, 2.6)],
        (2,13): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-5.3, -6.1), (-5.2, -9.0), (-7.2, -9.0), (-7.2, -5.0), (-6.9, -4), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (2,14): [(-2.8, -8.3), (-1.0, -8.3), (-1.0, -7.4), (-1.0, -6.1), (-5.3, -6.1), (-5.2, -9.0), (-7.2, -9.0), (-7.2, -5.0), (-6.9, -4), (-6.9, 0.5), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (3, 0): [(2.2, -8.0), (2.0, 0.4), (-5.2, 0.4), (-4.8, -2.2)],
        (3, 1): [(2.2, -8.0), (2.0, 0.4), (-5.2, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (3, 2): [(2.2, -8.0), (2.2, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (3, 4): [(2.2, -8.0), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (3, 5): [(2.2, -8.0), (2.2, -6.1), (2.0, -3.4), (6.0, -3.4)],
        (3, 6): [(2.2, -8.0), (2.2, -6.1), (2.0, 0.0), (6.0, 0.0)],
        (3, 7): [(2.2, -8.0), (2.2, -6.1), (2.0, 3.6), (6.0, 3.6)],
        (3, 8): [(2.2, -8.0), (2.2, -6.1), (2.0, 5.8), (6.8, 5.8), (6.8, 6.6), (6.8, 7.6), (6.8, 8.6), (5.0, 8.6)],
        (3, 9): [(2.2, -8.0), (2.2, -6.1), (2.0, 0.4), (-5.2, 0.4), (-5.2, 6.2), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (3,10): [(2.2, -8.0), (2.2, -6.1), (2.0, 0.4), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (3,11): [(2.2, -8.0), (2.2, -6.1), (2.0, -0.8), (1.6, -0.8), (1.0, -0.8), (-0.2, -2.8)],
        (3,12): [(2.2, -8.0), (2.2, -6.1), (2.0, 2.0), (2.0, 2.4), (1.0, 2.0), (-1.2, 2.6)],
        (3,13): [(2.2, -8.0), (2.2, -6.1), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (3,14): [(2.2, -8.0), (2.2, -6.1), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (4, 0): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.2, -6.1), (2.0, 0.4), (-5.2, 0.4), (-4.8, -2.2)],
        (4, 1): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.2, -6.1), (2.0, 0.4), (-5.2, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (4, 2): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (4, 3): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.2, -6.1), (2.2, -8.0)],
        (4, 5): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, -3.4), (6.0, -3.4)],
        (4, 6): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, 0.0), (6.0, 0.0)],
        (4, 7): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, 3.6), (6.0, 3.6)],
        (4, 8): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, 5.8), (6.8, 5.8), (6.8, 6.6), (6.8, 7.6), (6.8, 8.6), (5.0, 8.6)],
        (4, 9): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, 0.4), (-5.2, 0.4), (-5.2, 6.2), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (4,10): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, 0.4), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (4,11): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (-1.0, -6.1), (-1.0, -6.6), (-1.0, -5.0), (-0.2, -2.8)],
        (4,12): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, 2.0), (2.0, 2.4), (1.0, 2.0), (-1.2, 2.6)],
        (4,13): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (4,14): [(7.0, -9.0), (5.8, -7.8), (5.8, -6.1), (2.0, -6.1), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (5, 0): [(6.0, -3.4), (2.0, -3.4), (2.0, 0.4), (-5.2, -0.4), (-4.8, -2.2)],
        (5, 1): [(6.0, -3.4), (2.0, -3.4), (2.0, 0.4), (-5.2, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (5, 2): [(6.0, -3.4), (2.0, -3.4), (2.2, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (5, 3): [(6.0, -3.4), (2.0, -3.4), (2.2, -6.8), (2.2, -8.0)],
        (5, 4): [(6.0, -3.4), (2.0, -3.4), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (5, 6): [(6.0, -3.4), (2.0, -3.4), (2.0, 0.0), (6.0, 0.0)],
        (5, 7): [(6.0, -3.4), (2.0, -3.4), (2.0, 3.6), (6.0, 3.6)],
        (5, 8): [(6.0, -3.4), (2.0, -3.4), (2.0, 5.8), (6.8, 5.8), (6.8, 6.6), (6.8, 7.6), (6.8, 8.6), (5.0, 8.6)],
        (5, 9): [(6.0, -3.4), (2.0, -3.4), (2.0, 0.4), (-5.2, 0.4), (-5.2, 6.2), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (5,10): [(6.0, -3.4), (2.0, -3.4), (2.0, 0.4), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (5,11): [(6.0, -3.4), (2.0, -3.4), (2.0, -0.8), (1.6, -0.8), (1.0, -0.8), (-0.2, -2.8)],
        (5,12): [(6.0, -3.4), (2.0, -3.4), (2.0, 2.0), (2.0, 2.4), (1.0, 2.0), (-1.2, 2.6)],
        (5,13): [(6.0, -3.4), (2.0, -3.4), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (5,14): [(6.0, -3.4), (2.0, -3.4), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (6, 0): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (-5.2, -0.4), (-4.8, -2.2)],
        (6, 1): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (6, 2): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (2.2, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (6, 3): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (2.2, -6.8), (2.2, -8.0)],
        (6, 4): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (6, 5): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (2.0, -3.4), (6.0, -3.4)],
        (6, 7): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (2.0, 3.6), (6.0, 3.6)],
        (6, 8): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (2.0, 5.8), (6.8, 5.8), (6.8, 6.6), (6.8, 7.6), (6.8, 8.6), (5.0, 8.6)],
        (6, 9): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (-5.2, 0.4), (-5.2, 6.2), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (6,10): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (6,11): [(6.0, 0.0), (2.8, 0.0), (2.0, -0.8), (1.6, -0.8), (1.0, -0.8), (-0.2, -2.8)],
        (6,12): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (2.0, 2.0), (2.0, 2.4), (1.0, 2.0), (-1.2, 2.6)],
        (6,13): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (6,14): [(6.0, 0.0), (2.8, 0.0), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (7, 0): [(6.0, 3.6), (2.0, 3.6), (2.0, 0.4), (-5.3, -4.3), (-4.8, -2.2)],
        (7, 1): [(6.0, 3.6), (2.0, 3.6), (2.0, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (7, 2): [(6.0, 3.6), (2.0, 3.6), (2.2, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (7, 3): [(6.0, 3.6), (2.0, 3.6), (2.2, -6.8), (2.2, -8.0)],
        (7, 4): [(6.0, 3.6), (2.0, 3.6), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (7, 5): [(6.0, 3.6), (2.0, 3.6), (2.0, -3.4), (6.0, -3.4)],
        (7, 6): [(6.0, 3.6), (2.0, 3.6), (2.0, 0.0), (6.0, 0.0)],
        (7, 8): [(6.0, 3.6), (2.0, 3.6), (2.0, 5.8), (6.8, 5.8), (6.8, 6.6), (6.8, 7.6), (6.8, 8.6), (5.0, 8.6)],
        (7, 9): [(6.0, 3.6), (2.0, 3.6), (2.0, 0.4), (-5.2, 0.4), (-5.2, 6.2), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (7,10): [(6.0, 3.6), (2.0, 3.6), (2.0, 0.4), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (7,11): [(6.0, 3.6), (2.0, 3.6), (2.0, -0.8), (1.6, -0.8), (1.0, -0.8), (-0.2, -2.8)],
        (7,12): [(6.0, 3.6), (2.0, 3.6), (2.0, 2.0), (2.0, 2.4), (1.0, 2.0), (-1.2, 2.6)],
        (7,13): [(6.0, 3.6), (2.0, 3.6), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (7,14): [(6.0, 3.6), (2.0, 3.6), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (8, 0): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, 0.4), (-5.2, 0.4), (-4.8, -2.2)],
        (8, 1): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (8, 2): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (8, 3): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, -6.1), (2.2, -6.8), (2.2, -8.0)],
        (8, 4): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, -6.1), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (8, 5): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, -3.4), (6.0, -3.4)],
        (8, 6): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, 0.0), (6.0, 0.0)],
        (8, 7): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, 3.6), (6.0, 3.6)],
        (8, 9): [(5.0, 8.6), (6.8, 8.6), (6.8, 6.6), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (8,10): [(5.0, 8.6), (6.8, 8.6), (6.8, 6.6), (-3.6, 6.6), (-3.6, 5.4), (-3.6, 3.6)],
        (8,11): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, -0.8), (1.6, -0.8), (1.0, -0.8), (-0.2, -2.8)],
        (8,12): [(5.0, 8.6), (6.8, 8.6), (6.8, 8.2), (6.8, 5.8), (2.0, 5.8), (2.0, 2.0), (2.0, 2.4), (1.0, 2.0), (-1.2, 2.6)],
        (8,13): [(5.0, 8.6), (6.8, 8.6), (6.8, 6.6), (-5.2, 6.6), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (8,14): [(5.0, 8.6), (6.8, 8.6), (6.8, 6.6), (-5.2, 6.6), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (9, 0): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2)],
        (9, 1): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-5.2, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (9, 2): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (9, 3): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.2, -6.8), (5.8, -9)],
        (9, 4): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.2, -6.8), (5.8, -6.8), (5.8, -6.8), (7.0, -9.0)],
        (9, 5): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.0, -3.4), (6, -3.2)],
        (9, 6): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-5.2, 5.8), (2.0, 5.8), (2.0, 0.0), (6.0, 0.0)],
        (9, 7): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 5.8), (2.0, 5.8), (2.0, 3.6), (6.0, 3.6)],
        (9, 8): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 7), (-1.8, 8.6), (5.0, 8.6)],
        (9,10): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-3.6, 5.8), (-3.6, 6.0), (-3.6, 3.6)],
        (9,11): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -6.6), (-1.0, -5.0), (-0.2, -2.8)],
        (9,12): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-1.8, 5.8), (-1.8, 5.4), (-1.8, 4.8), (-1.2, 2.6)],
        (9,13): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-7.2, 5.0), (-7.0, 5.0)],
        (9,14): [(-6.0, 8.0), (-4.8, 7.6), (-4.8, -7.2), (-4.8, 6.6), (-5.2, 4.8), (-7.2, 5.0), (-7.2, 2.8)],

        (10, 0): [(-3.6, 3.6), (-3.6, 1.0), (-5.2, 0.4), (-4.8, -2.2)],
        (10, 1): [(-3.6, 3.6), (-3.6, 1.0), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (10, 2): [(-3.6, 3.6), (-3.6, 1.0), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (10, 3): [(-3.6, 3.6), (-3.6, 1.0), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.2, -6.8), (5.8, -9)],
        (10, 4): [(-3.6, 3.6), (-3.6, 1.0), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.2, -6.8), (5.8, -6.8), (5.8, -6.8), (7.0, -9.0)],
        (10, 5): [(-3.6, 3.6), (-3.6, 1.0), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.0, -3.4), (6, -3.2)],
        (10, 6): [(-3.6, 3.6), (-3.6, 5.8), (2.0, 5.8), (2.0, 0.0), (6.0, 0.0)],
        (10, 7): [(-3.6, 3.6), (-3.6, 5.8), (2.0, 5.8), (2.0, 3.6), (6.0, 3.6)],
        (10, 8): [(-3.6, 3.6), (-3.6, 5.8), (-1.8, 5.8), (-1.8, 7), (-1.8, 8.6), (5.0, 8.6)],
        (10, 9): [(-3.6, 3.6), (-3.6, 5.8), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (10,11): [(-3.6, 3.6), (-3.6, 1.0), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -6.6), (-1.0, -5.0), (-0.2, -2.8)],
        (10,12): [(-3.6, 3.6), (-3.6, 5.8), (-1.8, 5.8), (-1.8, 5.4), (-1.8, 4.8), (-1.2, 2.6)],
        (10,13): [(-3.6, 3.6), (-3.6, 1.0), (-5.2, 1.0), (-5.2, 4.8), (-7.2, 5.0), (-7.0, 5.0)],
        (10,14): [(-3.6, 3.6), (-3.6, 1.0), (-5.2, 1.0), (-5.2, 4.8), (-7.2, 5.0), (-7.2, 2.8)],

        (11, 0): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, 0.4), (-5.2, 0.4), (-4.8, -2.2)],
        (11, 1): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (11, 2): [(-0.2, -2.8), (-1.0, -5.0), (-1.0, 5.4), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (11, 3): [(-0.2, -2.8), (-1.0, -5.0), (-1.0, 5.4), (-1.0, -6.1), (1.6, -6.1), (2.2, -6.8), (2.2, -8.0)],
        (11, 4): [(-0.2, -2.8), (-1.0, -5.0), (-1.0, 5.4), (-1.0, -6.1), (1.6, -6.1), (2.2, -6.8), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (11, 5): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, -3.4), (6.0, -3.4)],
        (11, 6): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.8, 0.0), (6.0, 0.0)],
        (11, 7): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, 3.6), (6.0, 3.6)],
        (11, 8): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, 5.8), (6.8, 5.8), (6.8, 6.6), (6.8, 7.6), (6.8, 8.6), (5.0, 8.6)],
        (11, 9): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, 0.4), (-5.2, 0.4), (-5.2, 6.2), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (11,10): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.2, 0.4), (-3.6, 1.0), (-3.6, 1.6), (-3.6, 3.6)],
        (11,12): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, 2.0), (2.0, 2.4), (1.0, 2.0), (-1.2, 2.6)],
        (11,13): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (11,14): [(-0.2, -2.8), (1.0, -0.8), (1.4, -0.8), (2.0, -0.8), (2.0, 0.4), (-5.2, 0.4), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (12, 0): [(-1.2, 2.6), (-1.8, 4.8), (-1.8, 5.2), (-1.8, 5.8), (-5.2, 6.6), (-5.2, 0.4), (-4.8, -2.2)],
        (12, 1): [(-1.2, 2.6), (-1.8, 4.8), (-1.8, 5.2), (-1.8, 5.8), (-5.2, 6.6), (-5.2, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (12, 2): [(-1.2, 2.6), (-1.8, 4.8), (-1.8, 6.6), (-5.2, 6.6), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (12, 3): [(-1.2, 2.6), (1.0, 2.0), (1.4, 2.0), (2.0, 2.0), (2.2, -6.4), (2.2, -8.0)],
        (12, 4): [(-1.2, 2.6), (1.0, 2.0), (1.4, 2.0), (2.0, 2.0), (2.2, -6.4), (5.8, -6.8), (5.8, -7.8), (7.0, -9.0)],
        (12, 5): [(-1.2, 2.6), (1.0, 2.0), (1.4, 2.0), (2.0, 2.0), (2.2, -3.2), (6.0, -3.4)],
        (12, 6): [(-1.2, 2.6), (1.0, 2.0), (1.4, 2.0), (2.0, 2.0), (2.0, 0.0), (6.0, 0.0)],
        (12, 7): [(-1.2, 2.6), (1.0, 2.0), (1.4, 2.0), (2.0, 2.0), (2.0, 3.6), (6.0, 3.6)],
        (12, 8): [(-1.2, 2.6), (-1.8, 4.8), (-1.8, 8.6), (5.0, 8.6)],
        (12, 9): [(-1.2, 2.6), (-1.8, 4.8), (-1.8, 6.6), (-4.8, 6.6), (-4.8, 7.0), (-4.8, 7.6), (-6.0, 8.0)],
        (12,10): [(-1.2, 2.6), (-1.8, 4.8), (-1.8, 6.6), (-3.6, 6.6), (-3.6, 5.4), (-3.6, 3.6)],
        (12,11): [(-1.2, 2.6), (1.0, 2.0), (1.4, 2.0), (2.0, 2.0), (2.2, -0.8), (1.0, -0.8), (-0.2, -2.8)],
        (12,13): [(-1.2, 2.6), (-1.8, 4.8), (-1.8, 5.2), (-1.8, 5.8), (-5.2, 6.6), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.0, 5.0)],
        (12,14): [(-1.2, 2.6), (-1.8, 4.8), (-1.8, 5.2), (-1.8, 5.8), (-5.2, 6.6), (-5.2, 4.8), (-6.0, 4.8), (-7.2, 4.8), (-7.2, 2.8)],

        (13, 0): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2)],
        (13, 1): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 0.4), (-6.9, 0.5), (-6.9, -4.0), (-7.2, -5.0), (-7.2, -9.0)],
        (13, 2): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -7.4), (-1.0, -8.3), (-2.8, -8.3)],
        (13, 3): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.2, -6.8), (5.8, -9)],
        (13, 4): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.2, -6.8), (5.8, -6.8), (5.8, -6.8), (7.0, -9.0)],
        (13, 5): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (2.0, -6.1), (2.0, -3.4), (6, -3.2)],
        (13, 6): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 5.8), (2.0, 5.8), (2.0, 0.0), (6.0, 0.0)],
        (13, 7): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 5.8), (2.0, 5.8), (2.0, 3.6), (6.0, 3.6)],
        (13, 8): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 7), (-1.8, 8.6), (5.0, 8.6)],
        (13, 9): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-4.8, 7.6), (-5.8, 6.6), (-7, -7)],
        (13,10): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 5.8), (-3.6, 5.8), (-3.6, 6.0), (-3.6, 3.6)],
        (13,11): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 0.4), (-4.8, -2.2), (-4.8, -3.7), (-5.3, -4.3), (-5.3, -6.1), (-1.0, -6.1), (-1.0, -6.6), (-1.0, -5.0), (-0.2, -2.8)],
        (13,12): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8), (-5.2, 5.8), (-1.8, 5.8), (-1.8, 5.4), (-1.8, 4.8), (-1.2, 2.6)],
        (13,13): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8)],
        (13,14): [(-7.0, 5.0), (-7.0, 4.8), (-6.0, 4.8), (-5.2, 4.8)]
    }
}

all_map_distance_matrices = {
    0: [
        [0.0, 6.2, 0.0, 5.0],
        [6.2, 0.0, 0.0, 11.2],
        [2.2, 8.4, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0],
    ],
    1: [
        [0.0, 5.1, 5.2, 6.4, 7.8, 0.0, 3.9],
        [5.1, 0.0, 8.8, 10.8, 12.8, 5.1, 7.3],
        [5.2, 8.8, 0.0, 8.9, 12.0, 5.2, 9.0],
        [6.4, 10.8, 8.9, 0.0, 12.7, 6.4, 10.2],
        [7.8, 12.8, 12.0, 12.7, 0.0, 7.8, 11.1],
        [0.0, 5.1, 5.2, 6.4, 7.8, 0.0, 3.9],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
    ],
    2: [
        [0.0, 11.0, 13.4, 13.8, 11.6, 12.2, 10.1, 4.6, 1.4, 6.8],
        [11.0, 0.0, 11.7, 12.1, 9.9, 14.8, 12.7, 14.8, 10.3, 12.0],
        [13.4, 11.7, 0.0, 8.4, 9.0, 16.3, 14.2, 17.4, 12.9, 14.6],
        [13.8, 12.1, 8.4, 0.0, 8.5, 14.9, 12.8, 16.9, 12.4, 14.0],
        [11.6, 9.9, 9.0, 9.5, 0.0, 14.6, 12.5, 15.7, 11.2, 12.8],
        [12.2, 14.8, 16.3, 16.8, 14.6, 0.0, 2.0, 16.6, 12.2, 14.8],
        [10.1, 12.7, 14.2, 14.7, 12.5, 2.1, 0.0, 14.5, 10.1, 12.7],
        [4.6, 14.8, 17.4, 17.9, 15.7, 16.6, 14.5, 0.0, 4.5, 10.0],
        [1.4, 10.3, 12.9, 13.4, 11.2, 12.2, 10.1, 4.5, 0.0, 5.6],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
    ],
    3: [
        [0.0, 13.9, 12.4, 13.1, 18.2, 18.1, 21.5, 21.4, 21.0, 11.5, 6.0, 12.8, 14.7, 9.3, 11.0],
        [13.9, 0.0, 13.2, 13.9, 19.0, 19.8, 23.2, 30.0, 29.6, 19.9, 15.5, 13.6, 23.3, 17.9, 19.6],
        [27.1, 13.2, 0.0, 8.7, 13.8, 13.7, 17.1, 20.7, 42.8, 33.3, 28.7, 8.4, 36.5, 31.1, 32.8],
        [18.2, 26.8, 9.1, 0.0, 7.5, 8.6, 12.0, 15.6, 23.2, 24.2, 16.6, 10.5, 13.8, 22.3, 24.0],
        [23.3, 31.9, 14.2, 8.9, 0.0, 13.9, 17.3, 20.9, 28.5, 29.5, 21.9, 14.6, 19.1, 27.6, 29.3],
        [16.9, 26.2, 13.9, 8.6, 13.7, 0.0, 11.4, 15.0, 22.6, 23.6, 16.0, 9.9, 13.2, 21.7, 23.4],
        [13.2, 22.5, 17.8, 12.5, 17.6, 11.9, 0.0, 11.3, 18.9, 19.9, 12.3, 7.7, 9.5, 18.0, 19.7],
        [18.0, 25.6, 20.9, 15.6, 20.7, 15.0, 11.6, 0.0, 15.6, 23.0, 15.4, 11.7, 9.4, 21.1, 22.8],
        [24.6, 33.2, 28.3, 23.2, 28.3, 22.6, 19.2, 15.6, 0.0, 17.7, 17.2, 19.3, 17.0, 19.9, 21.6],
        [38.7, 47.4, 51.1, 55.1, 57.0, 56.8, 49.7, 44.2, 43.8, 0.0, 33.9, 51.6, 36.3, 33.9, 35.9],
        [6.9, 15.5, 19.3, 23.3, 25.2, 25.0, 17.6, 14.0, 13.6, 5.9, 0.0, 19.8, 7.3, 10.2, 12.2],
        [14.4, 23.0, 28.2, 29.0, 34.1, 9.9, 7.7, 11.7, 19.3, 20.4, 13.0, 0.0, 9.9, 18.4, 20.1],
        [15.6, 24.2, 28.7, 13.3, 18.0, 12.3, 9.3, 8.9, 12.9, 9.3, 8.9, 9.6, 0.0, 10.9, 12.6],
        [9.0, 17.6, 21.4, 25.4, 27.2, 27.1, 20.0, 16.4, 16.0, 19.9, 7.2, 21.9, 9.7, 2.0, 2.0],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
    ],
}

class DistanceMatrixCalculator:
    def __init__(self, all_map_reference_waypoints):
        self.all_map_reference_waypoints = all_map_reference_waypoints
        self.distance_matrices = {}

    @staticmethod
    def calculate_distance_between_points(point1, point2):
        x1, y1 = point1
        x2, y2 = point2
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

    def calculate_distance_matrix(self, reference_waypoints_map):
        node_indices = set()
        for (start, end) in reference_waypoints_map.keys():
            node_indices.add(start)
            node_indices.add(end)
        n_nodes = max(node_indices) + 1

        dist_matrix = [[0.0 for _ in range(n_nodes)] for _ in range(n_nodes)]

        for (start, end), waypoints in reference_waypoints_map.items():
            if not waypoints:
                continue
            path = waypoints.copy()
            total_distance = 0
            for i in range(len(path) - 1):
                total_distance += self.calculate_distance_between_points(path[i], path[i+1])
            dist_matrix[start][end] = round(total_distance, 1)

        return dist_matrix

    def calculate_all_distance_matrices(self):
        for map_id, waypoints_map in self.all_map_reference_waypoints.items():
            if waypoints_map:
                dist_mat = self.calculate_distance_matrix(waypoints_map)
                self.distance_matrices[map_id] = dist_mat
            else:
                self.distance_matrices[map_id] = []
        return self.distance_matrices

    def print_distance_matrices(self):
        for map_id, dist_mat in self.distance_matrices.items():
            print(f"Map ID {map_id}:")
            print("[")
            for row in dist_mat:
                row_str = [f"{d:.1f}" for d in row]
                print(f"        [{', '.join(row_str)}],")
            print("]")
            print()

class Map:
    def print_occupancy_grid_map(self, 
            map_path
        ) -> None:
        if not os.path.exists(map_path):
            raise FileNotFoundError(f"Map file not found: {map_path}")
        wall_grid = FloorMap.from_file(map_path).to_map_info(0, None, 0.0).wall_grid
        for row in wall_grid.astype(int):
            print(''.join(map(str, row)))

    def string_to_np_array_map(self, 
            string_map: str
        ) -> np.ndarray:
        return np.array([list(map(int, line)) 
                        for line in string_map.strip().splitlines() 
                        if line.strip()], dtype=np.int8)
        
    def np_array_to_string_map(self, 
            array_map: np.ndarray
        ) -> str:
        lines = ["".join(map(str, row)) for row in array_map]
        return "\n".join(lines)

    def occupancy_grid_to_distance_map(self, 
            occupancy_grid_map: np.ndarray, map_resolution: float
        ) -> np.ndarray:
        dist_map = distance_transform_edt(occupancy_grid_map == 0)
        dist_map = dist_map * map_resolution
        dist_map = np.round(dist_map, 2) 
        return dist_map

    def upscale_occupancy_grid_map(self, 
            occupancy_grid_map: np.ndarray, 
            scale: int
        ) -> np.ndarray:
        if scale == 1:
            return occupancy_grid_map.copy()
        
        upscaled_map = zoom(occupancy_grid_map, zoom=scale, order=0) 
        return upscaled_map

if __name__ == "__main__":
    """
    cd ~/ros_ws
    source install/setup.bash
    cd src/self_drive_sim/self_drive_sim/agent/
    python3 agent.py
    """
    # calculator = DistanceMatrixCalculator(all_map_reference_waypoints)
    # calculator.calculate_all_distance_matrices()
    # calculator.print_distance_matrices()

    # Generate occupancy grid map
    # map_ = Map()
    # map_.print_occupancy_grid_map('./../../worlds/map0.npz')

@dataclass
class Pose:
    _x: float = 0.0
    _y: float = 0.0
    _yaw: float = 0.0

    def __post_init__(self):
        self.yaw = self._yaw

    def normalize_yaw(self):
        self._yaw = math.atan2(math.sin(self._yaw), math.cos(self._yaw))

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, value):
        self._y = value

    @property
    def yaw(self):
        return self._yaw

    @yaw.setter
    def yaw(self, value):
        self._yaw = value
        self.normalize_yaw()

    def update(self, x: float, y: float, yaw: float):
        self.x = x 
        self.y = y 
        self.yaw = yaw

@dataclass
class Particle:
    pose: Pose = field(default_factory=Pose)
    weight: float = 0.0

class MonteCarloLocalizer:
    def __init__(self,
            particle_num=100,
            initial_pose_noise_std=[0.02, 0.02, 0.02], # [x, y, yaw]
            odom_noise_std=[0.01, 0.002, 0.002, 0.01],

            # Weight
            scan_min_range=0.05,
            scan_max_range=8.0,
            scan_min_angle=-1.9,
            scan_angle_increment=0.016,
            scan_step=3,
            sigma_hit=0.2,
            unknown_class_prior=0.5,
            known_class_prior=0.5,
            z_hit=0.9,
            z_max=0.05,
            z_rand=0.05,
            unknown_class_lambda_=1.0,
            baselink_to_laser=[0.147, 0.0, 0.0],  # [x, y, yaw(rad)]

            # Resamping
            omega_slow=0.0,
            omega_fast=0.0,
            alpha_slow=0.001,
            alpha_fast=0.9,
            resample_ess_ratio=0.5,
            delta_distance_resample_threshold=0.2,
            delta_yaw_resample_threshold=0.02,
            random_resampling_noise_std=[0.02, 0.02, 0.02] # [x, y, yaw]
        ):
        
        # Constants
        self.particle_num = particle_num
        self.initial_pose_noise_std = initial_pose_noise_std
        self.odom_noise_std = odom_noise_std
        self.scan_min_angle = scan_min_angle
        self.scan_angle_increment = scan_angle_increment
        self.scan_min_range = scan_min_range
        self.scan_max_range = scan_max_range
        self.scan_step = scan_step
        self.sigma_hit = sigma_hit
        self.unknown_class_prior = unknown_class_prior
        self.known_class_prior = known_class_prior
        self.z_hit = z_hit
        self.z_max = z_max
        self.z_rand = z_rand
        self.unknown_class_lambda_ = unknown_class_lambda_
        self.baselink_to_laser = baselink_to_laser
        self.omega_slow = omega_slow
        self.omega_fast = omega_fast
        self.alpha_slow = alpha_slow
        self.alpha_fast = alpha_fast
        self.resample_ess_ratio = resample_ess_ratio
        self.delta_distance_resample_threshold = delta_distance_resample_threshold
        self.delta_yaw_resample_threshold = delta_yaw_resample_threshold
        self.random_resampling_noise_std = random_resampling_noise_std

        # Particle set
        self.particles = []   

        # estimate_robot_pose (used by resample_particles)
        self.estimated_x = None
        self.estimated_y = None
        self.estimated_yaw = None

        # resample_particles
        self.delta_distance_abs_sum = 0
        self.delta_yaw_abs_sum = 0
        self.average_likelihood = 0

    def initialize_particles(
            self, 
            initial_pose: Pose
        ) -> None:
        """
        Parameters
        ----------
        - initial_pose: initial pose of robot (x, y, yaw)
        
        Update
        ------
        - self.particles: initialized particles

        Using
        -----
        - self.particle_num
        - self.initial_pose_noise_std
        """
        particle_xs = initial_pose.x + np.random.normal(0, self.initial_pose_noise_std[0], self.particle_num)
        particle_ys = initial_pose.y + np.random.normal(0, self.initial_pose_noise_std[1], self.particle_num)
        particle_yaws = initial_pose.yaw + np.random.normal(0, self.initial_pose_noise_std[2], self.particle_num)
        
        initial_weight = 1.0 / self.particle_num
    
        self.particles = [
            Particle(
                pose=Pose(particle_xs[i], particle_ys[i], particle_yaws[i]),
                weight=initial_weight
            )
            for i in range(self.particle_num)
        ]
    
    def update_particles_by_motion_model(self, 
            delta_distance: float, 
            delta_yaw: float
        ) -> None:
        """
        Parameters
        ----------
        - delta_distance: measured by IMU
        - delta_yaw
        
        Update
        ------
        - self.particles

        Using
        -----
        - self.odom_noise_std
        """
        # Update self.delta_distance_abs_sum and self.delta_yaw_abs_sum for resampling
        self.delta_distance_abs_sum += abs(delta_distance)
        self.delta_yaw_abs_sum += abs(delta_yaw)

        # Standard deviation (noise)
        squared_delta_distance = delta_distance * delta_distance
        squared_delta_yaw = delta_yaw * delta_yaw
        std_dev_distance = math.sqrt(self.odom_noise_std[0] * squared_delta_distance + self.odom_noise_std[1] * squared_delta_yaw)
        std_dev_yaw = math.sqrt(self.odom_noise_std[2] * squared_delta_distance + self.odom_noise_std[3] * squared_delta_yaw)
        for particle in self.particles:
            # Differential drive model
            noisy_delta_distance = delta_distance + np.random.normal(0, std_dev_distance)
            noisy_delta_yaw = delta_yaw + np.random.normal(0, std_dev_yaw)
            yaw = particle.pose.yaw
            t = yaw + noisy_delta_yaw / 2.0
            
            updated_x = particle.pose.x + noisy_delta_distance * math.cos(t)
            updated_y = particle.pose.y + noisy_delta_distance * math.sin(t)
            updated_yaw = yaw + noisy_delta_yaw
						
			# update each particle	
            particle.pose.update(updated_x, updated_y, updated_yaw)

    def update_weights_by_measurement_model(
            self,
            scan_ranges: np.ndarray,
            occupancy_grid_map: np.ndarray,
            distance_map: np.ndarray,
            map_origin=(float, float),
            map_resolution= float,
        ) -> None:
        """
        Parameters
        ----------
        - scan_ranges
        - occupancy_grid_map
        - distance_map
        - map_origin
        - map_resolution

        Update
        ------
        - self.particles

        Using
        -----
        - self.particle_num
        - self.scan_min_angle
        - self.scan_angle_increment
        - self.scan_min_range
        - self.scan_max_range
        - self.scan_step
        - self.sigma_hit
        - self.z_hit
        - self.z_max
        - self.z_rand
        - self.baselink_to_laser
        - self.known_class_prior
        - self.unknown_class_prior
        - self.unknown_class_lambda_
        """
        # Fixed parameters for likelihood field model
        gaussian_normalization_constant = 1.0 / math.sqrt(2.0 * math.pi * self.sigma_hit**2)
        gaussian_exponent_factor = 1.0 / (2 * self.sigma_hit ** 2)
        probability_rand = 1.0 / self.scan_max_range
 
        eps = 1e-12

        beam_num = len(scan_ranges)
        sampled_beam_indices = np.arange(0, beam_num, self.scan_step)
        sampled_beam_angles = self.scan_min_angle + sampled_beam_indices * self.scan_angle_increment
        sampled_scan_ranges = scan_ranges[sampled_beam_indices]
        
        # Map constant
        map_height, map_width = occupancy_grid_map.shape
        map_origin_x, map_origin_y = map_origin
        
        # Initialize particle weight
        log_weights = np.zeros(self.particle_num, dtype=np.float64)
        
        # previous
        particle_yaws = np.array([particle.pose.yaw for particle in self.particles])
        particle_cos_yaws = np.cos(particle_yaws)
        particle_sin_yaws = np.sin(particle_yaws)
        
        particle_xs = np.array([particle.pose.x for particle in self.particles])
        particle_ys = np.array([particle.pose.y for particle in self.particles])
        
        # Previous calculation cos and sine for beam angle
        cos_sampled_beam_angles = np.cos(sampled_beam_angles)
        sin_sampled_beam_angles = np.sin(sampled_beam_angles)
        
        for particle_index in range(self.particle_num):
            particle_x = particle_xs[particle_index]
            particle_y = particle_ys[particle_index]
            particle_yaw = particle_yaws[particle_index]
            cos_yaw = particle_cos_yaws[particle_index]
            sin_yaw = particle_sin_yaws[particle_index]

            sensor_x = particle_x + self.baselink_to_laser[0] * cos_yaw - self.baselink_to_laser[1] * sin_yaw
            sensor_y = particle_y + self.baselink_to_laser[0] * sin_yaw + self.baselink_to_laser[1] * cos_yaw
            sensor_yaw = particle_yaw + self.baselink_to_laser[2]
         
            log_likelihood = 0.0
            sampled_beam_num = len(sampled_scan_ranges)
            for beam_index in range(sampled_beam_num):
                # Distance measured by lidar 
                range_measurement = sampled_scan_ranges[beam_index]
                
                # Likelihood field model as known class probability
                if not (self.scan_min_range < range_measurement < self.scan_max_range) or np.isinf(range_measurement) or np.isnan(range_measurement):
                    class_conditional_probability = self.z_max + self.z_rand * probability_rand
                else:
                    direction_x = np.cos(sensor_yaw) * cos_sampled_beam_angles[beam_index] - np.sin(sensor_yaw) * sin_sampled_beam_angles[beam_index]
                    direction_y = np.sin(sensor_yaw) * cos_sampled_beam_angles[beam_index] + np.cos(sensor_yaw) * sin_sampled_beam_angles[beam_index]
                    lidar_hit_x = sensor_x + range_measurement * direction_x
                    lidar_hit_y = sensor_y + range_measurement * direction_y
                    map_index_x = int(round((lidar_hit_x - map_origin_x) / map_resolution))
                    map_index_y = int(round((lidar_hit_y - map_origin_y) / map_resolution))
                    
                    if 0 <= map_index_x < map_height and 0 <= map_index_y < map_width:
                        distance = distance_map[map_index_x, map_index_y] # [m]
                        
                        probability_hit = gaussian_normalization_constant * math.exp( -(distance ** 2) * gaussian_exponent_factor) * map_resolution

                        known_class_probability = (self.z_hit * probability_hit + self.z_rand * probability_rand) * self.known_class_prior
                    else:
                        known_class_probability = (self.z_rand * probability_rand) * self.known_class_prior

                    # Exponential distribution as unknown class probability
                    unknown_class_probability = self.unknown_class_lambda_ * math.exp(-self.unknown_class_lambda_ * range_measurement) / (1 - math.exp(-self.unknown_class_lambda_ * self.scan_max_range)) * map_resolution * self.unknown_class_prior
                    class_conditional_probability = known_class_probability + unknown_class_probability

                log_likelihood += math.log(class_conditional_probability + eps)
        
            log_weights[particle_index] = log_likelihood
            
        # Normalize log-sum-exp
        max_log_weight = np.max(log_weights)
        exp_weights = np.exp(log_weights - max_log_weight)
        normalized_weights = exp_weights / (np.sum(exp_weights) + eps)
        
        # allocate weight to particle
        for index, particle in enumerate(self.particles):
            particle.weight = max(normalized_weights[index], eps)
        
        total_weight = sum(particle.weight for particle in self.particles)
        if total_weight > 0:
            for particle in self.particles:
                particle.weight /= total_weight

        # Average likelihood for resampling
        self.average_likelihood = np.mean([particle.weight for particle in self.particles])

    def estimate_robot_pose(self):
        """
        Update
        -------
        - self.estimated_x
        - self.estimated_y
        - self.estimated_yaw

        Using
        ------
        - self.particles
        """        
        xs = np.array([particle.pose.x for particle in self.particles])
        ys = np.array([particle.pose.y for particle in self.particles])
        yaws = np.array([particle.pose.yaw for particle in self.particles])
        weights = np.array([particle.weight for particle in self.particles])
        
        # Weighted sum for x and y
        self.estimated_x = np.sum(xs * weights)
        self.estimated_y = np.sum(ys * weights)
        
        # Weighted sum for yaw
        cos_yaw = np.sum(np.cos(yaws) * weights)
        sin_yaw = np.sum(np.sin(yaws) * weights)
        self.estimated_yaw = math.atan2(sin_yaw, cos_yaw)

    def calculate_amcl_random_resampling_particle_rate(self,
            average_likelihood
        ):
        self.omega_slow += self.alpha_slow * (average_likelihood - self.omega_slow)
        self.omega_fast += self.alpha_fast * (average_likelihood - self.omega_fast)
        amcl_random_particle_rate = 1.0 - self.omega_fast / self.omega_slow
        return max(amcl_random_particle_rate, 0.0)

    def calculate_effective_sample_size(self):
        weights = np.array([particle.weight for particle in self.particles])
        weight_sum = np.sum(weights**2)
        effective_sample_size = 1.0 / weight_sum
        return effective_sample_size

    # def resample_particles(self):
    #     """
    #     Update
    #     ------
    #     - self.particles

    #     Using
    #     -----
    #     - self.particle_num
    #     - self.omega_slow
    #     - self.omega_fast
    #     - self.alpha_slow
    #     - self.alpha_slow
    #     - self.resample_ess_ratio
    #     - self.estimated_x
    #     - self.estimated_y
    #     - self.estimated_yaw
    #     - self.random
    #     """
    #     # Inspect effective sample size
    #     threshold = self.particle_num * self.resample_ess_ratio
    #     effective_sample_size = self.calculate_effective_sample_size()
    #     if effective_sample_size > threshold:
    #         return

    #     # Check movement threshold
    #     if self.delta_distance_abs_sum < self.delta_distance_resample_threshold and self.delta_yaw_abs_sum < self.delta_yaw_resample_threshold:
    #         return
    #     self.delta_distance_abs_sum = 0
    #     self.delta_yaw_abs_sum = 0

    #     # Normalize weights
    #     weights = np.array([particle.weight for particle in self.particles])
    #     weights /= np.sum(weights)  # normalize
    #     cumulative_sum = np.cumsum(weights)

    #     positions = (np.arange(self.particle_num) + np.random.uniform()) / self.particle_num
    #     indices = np.searchsorted(cumulative_sum, positions)

    #     # Resampled particles
    #     self.particles = [
    #         Particle(pose=Pose(
    #             _x=self.particles[i].pose.x,
    #             _y=self.particles[i].pose.y,
    #             _yaw=self.particles[i].pose.yaw),
    #             weight=1.0 / self.particle_num
    #         )
    #         for i in indices
    #     ]

    def resample_particles(self):
        """
        Update
        ------
        - self.particles

        Using
        -----
        - self.particle_num
        - self.omega_slow
        - self.omega_fast
        - self.alpha_slow
        - self.alpha_slow
        - self.resample_ess_ratio
        """
        # Inspect effective sample size
        threshold = self.particle_num * self.resample_ess_ratio
        effective_sample_size = self.calculate_effective_sample_size()
        if effective_sample_size > threshold:
            return

        # Check movement threshold
        if self.delta_distance_abs_sum < self.delta_distance_resample_threshold and self.delta_yaw_abs_sum < self.delta_yaw_resample_threshold:
            return
        self.delta_distance_abs_sum = 0
        self.delta_yaw_abs_sum = 0

        # Normalize weights
        weights = np.array([particle.weight for particle in self.particles])
        weights /= np.sum(weights)  # normalize
        cumulative_sum = np.cumsum(weights)

        # Calculate the number of random resampling particles
        random_resampling_rate = self.calculate_amcl_random_resampling_particle_rate(self.average_likelihood)
        random_resampling_particle_num = int(self.particle_num * random_resampling_rate)
        non_random_resampling_particle_num = self.particle_num - random_resampling_particle_num

        # Non-random resampling
        positions = (np.arange(non_random_resampling_particle_num) + np.random.uniform()) / self.particle_num
        indices = np.searchsorted(cumulative_sum, positions)

        # Resample non-random particles
        self.particles[:non_random_resampling_particle_num] = [
            Particle(
                pose=Pose(
                    _x=self.particles[i].pose.x,
                    _y=self.particles[i].pose.y,
                    _yaw=self.particles[i].pose.yaw
                ),
                weight=1.0 / self.particle_num
            )
            for i in indices
        ]

        # Resample random particles
        xo, yo, yawo = self.estimated_x, self.estimated_y, self.estimated_yaw
        self.particles[non_random_resampling_particle_num:] = [
            Particle(
                pose=Pose(
                    _x=xo + np.random.normal(0, self.random_resampling_noise_std[0]),
                    _y=yo + np.random.normal(0, self.random_resampling_noise_std[1]),
                    _yaw=yawo + np.random.normal(0, self.random_resampling_noise_std[2])
                ),
                weight=1.0 / self.particle_num
            )
            for i in range(non_random_resampling_particle_num, self.particle_num)
        ]

class GoToGoalController:
    def __init__(self,
            max_linear_velocity=1.0,
            max_angular_velocity=2.0,
            linear_velocity_gain=1.0,
            angular_velocity_gain=2.0,
            angle_threshold=0.05
        )->None:
        self.max_linear_velocity = max_linear_velocity
        self.max_angular_velocity = max_angular_velocity
        self.linear_velocity_gain = linear_velocity_gain
        self.angular_velocity_gain = angular_velocity_gain
        self.angle_threshold = angle_threshold

    def go_to_goal_controller(self, 
            current_robot_pose, 
            target_position
        )->tuple[float, float]:
        """
        Returns
        -------
        - linear_velocity
        - angular_velocity

        Usings
        ------
        - self.angle_threshold
        - self.max_angular_velocity
        - self.max_linear_velocity
        - self.linear_velocity_gain
        - self.angular_velocity_gain
        """
        current_robot_x, current_robot_y, current_robot_yaw = current_robot_pose
        target_x, target_y = target_position

        dx = current_robot_x - target_x
        dy = current_robot_y - target_y
        d_distance = math.hypot(dx, dy)

        target_angle = math.atan2(-dy, -dx)  
        d_yaw = math.atan2(math.sin(target_angle - current_robot_yaw),
                           math.cos(target_angle - current_robot_yaw))

        if abs(d_yaw) > self.angle_threshold:
            linear_velocity = 0.0
            angular_velocity = max(-self.max_angular_velocity,
                                   min(self.max_angular_velocity, self.angular_velocity_gain * d_yaw))
        else:
            linear_velocity = max(-self.max_linear_velocity,
                                  min(self.max_linear_velocity, self.linear_velocity_gain * d_distance))
            angular_velocity = max(-self.max_angular_velocity,
                                   min(self.max_angular_velocity, self.angular_velocity_gain * d_yaw))

        return linear_velocity, angular_velocity

class AutonomousNavigator:
    def __init__(self,
            initial_robot_pose,
            pollution_threshold=0.05,
            position_threshold=0.05
        )->None:
        # Constants
        self.pollution_threshold = pollution_threshold
        self.position_threshold = position_threshold

        # Class object
        self.mcl = MonteCarloLocalizer()
        self.go_to_goal_controller = GoToGoalController()
        self.local_costmap_generator = LocalCostMapGenerator()
        self.dynamic_obstacle_tracker = DynamicObstacleTracker()

        # Monte carlo localization
        self.mcl.initialize_particles(initial_robot_pose)

        # Finite state machine
        self.waypoints = []
        self.current_node_index = None
        self.optimal_next_node_index = None
        self.visited_regions = []
        self.cleaning_holding_time = 0

        # Local Planner
        self.lookahead_position_index = 0
        self.abc = None                   # logging for debugging
    
        # [test] move_along_nodes
        self.current_waypoint_index = 0
        self.tmp_target_position = None
        self.initial_flag = True
        self.i = 0

    def mission_planner(self, 
            air_pollution_sensor_data, 
            current_node_index,
            current_time,
            pollution_end_time,
            map_id
        ):
        """
        Deadline-Conditinoal Traveling Salmesman Problem Solver

        Parameters:
        - air_pollution_sensor_data
        - current_node_index
        - current_time
        - pollution_end_time
        - map_id: 0, 1, 2, 3

        Return
        ------
        - optimal_visit_order
        """
        selected_map_distance_matrix = all_map_distance_matrices.get(map_id) 
        docking_station_node_index = len(selected_map_distance_matrix) -1 # last index in distanec matrix

        # Polluted regions
        observed_polluted_regions = [
            node_index for node_index in range(len(air_pollution_sensor_data))
            if air_pollution_sensor_data[node_index] > self.pollution_threshold
        ]

        # Regioin with no air pollution sensor
        unobserved_potential_regions = [
            node_index for node_index in range(len(air_pollution_sensor_data))
            if math.isnan(air_pollution_sensor_data[node_index])
            and node_index not in self.visited_regions
        ]

        candidate_regions = []
        if current_time > pollution_end_time: 
            candidate_regions = observed_polluted_regions + unobserved_potential_regions
        else:
            candidate_regions = observed_polluted_regions

        if not candidate_regions:
            return []
        
        # Remove ---------------------------------------------------------------------------------------------------------------------------------------
        exclude_list = []
        candidate_regions = [x for x in candidate_regions if x not in exclude_list]

        # Calculate cost for for every cases and get global minima
        optimal_visit_order = []
        min_cost = float('inf')
        for perm in itertools.permutations(candidate_regions):
            total_cost = 0
            last_visited = current_node_index

            for node_index in perm:
                total_cost += selected_map_distance_matrix[last_visited][node_index]
                last_visited = node_index

            # Add Cost for last_visited to docking station
            total_cost += selected_map_distance_matrix[last_visited][docking_station_node_index]

            if total_cost < min_cost:
                min_cost = total_cost
                optimal_visit_order = list(perm)

        return optimal_visit_order
    
    def global_planner(self, 
            start_node_index, 
            end_node_index, 
            map_id
        ):
        """
        Index rules
        - index of region is a index of matrix
        - last index is for docking station
        - (last - 1) index is for start position
        
        reference_waypoint_matrix[i][j] : waypoints from start node i to end node j

        Parameters
        ----------
        - start_node_index
        - end_node_index
        - map_id

        Returns
        -------
        - selected_map_reference_waypoints[(start_node_index, end_node_index)]
        """
        # Check validity of map_id
        if map_id not in all_map_reference_waypoints:
            return None
        
        selected_map_reference_waypoints = all_map_reference_waypoints[map_id]

        # Check validity of node indexes
        if (start_node_index, end_node_index) not in selected_map_reference_waypoints:
            return None

        return selected_map_reference_waypoints[(start_node_index, end_node_index)]

    # Main Logic
    def finite_state_machine(self,
            air_pollution_sensor_data,
            robot_pollution_sensor_data,
            scan_ranges,
            current_time,
            pollution_end_time,
            current_robot_pose, 
            current_fsm_state,
            map_id,
            room_num,
            position_threshold=0.05
        ) -> tuple[str, tuple[float, float, float]]:
        """
        Parameters
        ----------
        - air_pollution_sensor_data
        - robot_pollution_sensor_data
        - current_time
        - pollution_end_time
        - current_robot_pose
        - current_fsm_state
        - map_id
        - room_num
        - position_threshold

        Returns
        -------
        - next_fsm_state: str
        - action: (float, float, float)

        Updates & Usings
        ---
        - self.current_node_index
        - self.optimal_next_node_index
        - self.waypoints
        - self.visited_regions
        - self.pollution_threshold
        - self.cleaning_holding_time

        - self.mission_planner()
        - self.global_planner()
        - self.local_planner()
        """
        # States of finite state machine
        FSM_READY = "READY"
        FSM_CLEANING = "CLEANING"
        FSM_NAVIGATING = "NAVIGATING"
        FSM_RETURNING = "RETURNING"

        current_robot_position = current_robot_pose[0], current_robot_pose[1]

        # Indexes of initial node and docking station node by map
        initial_node_index = room_num
        docking_station_node_index = room_num + 1

        # -------------------------------------------------------------------------------------------------------------------------------------------------------- #
        # [Start State] READY ------------------------------------------------------------------------------------------------------------------------------------ #
        # -------------------------------------------------------------------------------------------------------------------------------------------------------- #
        if current_fsm_state == FSM_READY:
            # Mission planning
            self.current_node_index = initial_node_index
            optimal_visit_order = self.mission_planner(
                air_pollution_sensor_data, 
                self.current_node_index,
                current_time,
                pollution_end_time,
                map_id
            )

            # Action: stop
            action = (0, 0, 0)

            # [State Transition] READY -> NAVIGATING
            if optimal_visit_order:
                next_fsm_state = FSM_NAVIGATING

                # Global planning
                self.optimal_next_node_index = optimal_visit_order[0]
                self.waypoints = self.global_planner(
                    start_node_index=initial_node_index, 
                    end_node_index=self.optimal_next_node_index, 
                    map_id=map_id
                )
            
            # [State Transition] READY -> READY
            else:
                next_fsm_state = FSM_READY

        # -------------------------------------------------------------------------------------------------------------------------------------------------------- #
        # [Intermediate State] Navigating ------------------------------------------------------------------------------------------------------------------------ #
        # -------------------------------------------------------------------------------------------------------------------------------------------------------- #
        elif current_fsm_state == FSM_NAVIGATING:
            # Local planning
            linear_velocity, angular_velocity = self.local_planner(
                current_robot_pose=current_robot_pose,
                waypoints=self.waypoints,
                scan_ranges=scan_ranges
            )
            action = (0, linear_velocity, angular_velocity)

            # [State Transition] NAVIGATING -> CLEANING
            if self.is_target_reached(current_robot_position, self.waypoints[-1], position_threshold): 
                next_fsm_state = FSM_CLEANING
                self.current_node_index = self.optimal_next_node_index
                self.visited_regions.append(self.current_node_index)
            
            # [State Transition] NAVIGATING -> NAVIGATING
            else:
                next_fsm_state = FSM_NAVIGATING

        # --------------------------------------------------------------------------------------------------------------------------------------------------------  #
        # [Intermediate State] CLEANING --------------------------------------------------------------------------------------------------------------------------  #
        # --------------------------------------------------------------------------------------------------------------------------------------------------------  #
        elif current_fsm_state == FSM_CLEANING:
            # Mission planning
            optimal_visit_order = self.mission_planner(
                air_pollution_sensor_data, 
                self.current_node_index,
                current_time,
                pollution_end_time,
                map_id
            )

            # Action: stop and cleaning
            action = (1, 0, 0)

            # [State Transition] CLEANING -> RETURNING
            if current_time >= pollution_end_time and (air_pollution_sensor_data[self.current_node_index] <= self.pollution_threshold or (robot_pollution_sensor_data != None and robot_pollution_sensor_data <= self.pollution_threshold)) and not optimal_visit_order:
                next_fsm_state = FSM_RETURNING

                # Global planning
                self.waypoints = self.global_planner(
                    start_node_index=self.current_node_index, 
                    end_node_index=docking_station_node_index,
                    map_id=map_id
                )
            
            # [Staet Transition] CLEANING -> RETURNING (early end mode)
            # if current_time >= pollution_end_time and (air_pollution_sensor_data[self.current_node_index] <= self.pollution_threshold or (robot_pollution_sensor_data != None and robot_pollution_sensor_data <= self.pollution_threshold)):
            #     next_fsm_state = FSM_RETURNING

            #     # Global planning
            #     self.waypoints = self.global_planner(
            #         start_node_index=self.current_node_index, 
            #         end_node_index=docking_station_node_index,
            #         map_id=map_id
            #     )

            # [State Transition] CLEANING -> NAVIGATING
            elif (air_pollution_sensor_data[self.current_node_index] <= self.pollution_threshold or (robot_pollution_sensor_data != None and robot_pollution_sensor_data <= self.pollution_threshold)) and optimal_visit_order:
                if self.cleaning_holding_time >= 5:
                    next_fsm_state = FSM_NAVIGATING

                    # Global planning
                    self.optimal_next_node_index = optimal_visit_order[0]
                    self.waypoints = self.global_planner(
                        start_node_index=self.current_node_index,
                        end_node_index=self.optimal_next_node_index,
                        map_id=map_id
                    )

                    self.cleaning_holding_time = 0
                else:
                    next_fsm_state = FSM_CLEANING
                    self.cleaning_holding_time += 1

            # [State Transition] CLEANING -> CLEANING
            else:
                next_fsm_state = FSM_CLEANING

        # -------------------------------------------------------------------------------------------------------------------------------------------------------- #
        # [End State] RETURNING ---------------------------------------------------------------------------------------------------------------------------------- #
        # -------------------------------------------------------------------------------------------------------------------------------------------------------- #
        elif current_fsm_state == FSM_RETURNING:
            next_fsm_state = FSM_RETURNING
            
            # Local planning
            linear_velocity, angular_velocity = self.local_planner(
                current_robot_pose=current_robot_pose,
                waypoints=self.waypoints,
                scan_ranges=scan_ranges
            )
            action = (0, linear_velocity, angular_velocity)

        return next_fsm_state, action
    
    def localizer(self, 
            delta_distance, 
            delta_yaw, 
            scan_ranges, 
            occupancy_grid_map, 
            distance_map, 
            map_origin, 
            map_resolution
        )->tuple[float, float, float]:
        """
        Parameters
        ----------
        - delta_distance
        - delta_yaw
        - scan_ranges
        - occupancy_grid_map
        - distance_map
        - map_origin
        - map_resolution

        Returns
        - current_robot_pose

        Usings
        ------
        - self.mcl.update_particles_by_motion_model()
        - self.mcl.update_weights_by_measurement_model()
        - self.mcl.estimate_robto_poes()
        - self.mcl.resample_particles()
        """
        self.mcl.update_particles_by_motion_model(
            delta_distance, 
            delta_yaw
        )
        self.mcl.update_weights_by_measurement_model(
            scan_ranges=scan_ranges,
            occupancy_grid_map=occupancy_grid_map,
            distance_map=distance_map,
            map_origin=map_origin,
            map_resolution=map_resolution
        )
        self.mcl.estimate_robot_pose()
        current_robot_pose = (self.mcl.estimated_x, self.mcl.estimated_y, self.mcl.estimated_yaw)

        self.mcl.resample_particles()

        return current_robot_pose

    def local_planner(self,
            current_robot_pose,
            waypoints,
            scan_ranges: np.ndarray
        ) -> tuple[float, float]:
        """
        Parameters
        ----------
        - current_robot_pose
        - waypoints
        - scan_ranges

        Returns
        -------
        - linear_velocity
        - angular_velocity

        Usings
        ------
        - self.lookahead_position_index

        - self.is_target_reached()
        - self.go_to_goal_controller()
        """
        current_robot_position = current_robot_pose[0], current_robot_pose[1]

        if self.is_target_reached(
                current_position=current_robot_position,
                target_position=waypoints[-1],
                position_threshold=self.position_threshold
            ):
            self.lookahead_position_index = 0

        lookahead_position = waypoints[self.lookahead_position_index]
        if self.is_target_reached(
                current_position=current_robot_position,
                target_position=lookahead_position,
                position_threshold=self.position_threshold
            ) and self.lookahead_position_index < len(waypoints) - 1:
            self.lookahead_position_index += 1
            lookahead_position = waypoints[self.lookahead_position_index]         

        linear_velocity, angular_velocity = self.go_to_goal_controller.go_to_goal_controller(
            current_robot_pose,
            lookahead_position
        )

        self.abc = self.perception(
            scan_ranges=scan_ranges,
            current_robot_pose=current_robot_pose
        )


        # Local costmap
        # local_costmap = self.local_costmap_generator.generate_costmap(
        #     scan_ranges=scan_ranges
        # )

        # height, width = local_costmap.shape
        # pixels_ahead = int(1.0 / 0.02)  # 1m / 0.02m (1 )

        # center_row = height // 2
        # center_col = width // 2

        # #    ( 1m , 3xN )
        # # center_row  1     1m   
        # front_region = local_costmap[center_row - 1 : center_row + 2, center_col : center_col + pixels_ahead]

        # #    
        # self.abc = np.any(front_region == self.local_costmap_generator.max_cost)

        return linear_velocity, angular_velocity

    def perception(self,
            scan_ranges: np.ndarray,
            current_robot_pose: tuple
        ):
        # num = self.dynamic_obstacle_tracker.update(
        #     scan_ranges=scan_ranges,
        #     current_robot_pose=current_robot_pose
        # )

        is_dynamic = self.dynamic_obstacle_tracker.update(
            scan_ranges=scan_ranges,
            current_robot_pose=current_robot_pose
        )

        return is_dynamic

    # Util functions
    def calculate_distance_to_target_position(self,
            current_position, 
            target_position
        )->float:
        """
        calculaet euclidean distance

        Parameters
        ----------
        - current_position: absolute x, absolute y
        - target_position

        Return
        ------
        - distance
        """
        dx = target_position[0] - current_position[0]
        dy = target_position[1] - current_position[1]
        distance = math.hypot(dx, dy)
        return distance
    
    def is_target_reached(self,
            current_position, 
            target_position, 
            position_threshold
        ):
        """
        Parameters
        ----------
        - current_position
        - target_position
        - position_threshold

        Return
        ------
        - True or False
        """
        return self.calculate_distance_to_target_position(current_position, target_position) < position_threshold

    # global plan test functoin
    def move_along_nodes(self,
            current_robot_pose,
            node_visit_queue,
            map_id,
            room_num
        ):        
        initial_node_index = room_num
        current_robot_position = current_robot_pose[0], current_robot_pose[1]

        if (self.initial_flag == True):
            self.current_node_index = initial_node_index
            self.optimal_next_node_index = node_visit_queue[0]
            self.waypoints = self.global_planner(
                initial_node_index,
                self.optimal_next_node_index,
                map_id
            )
            self.current_waypoint_index = 0
            self.tmp_target_position = self.waypoints[0]

            action = (0, 0, 0)
            self.i += 1
            self.initial_flag = False
        else:
            if self.is_target_reached(current_robot_position, self.waypoints[-1]):
                self.current_waypoint_index = 0
                self.current_node_index = self.optimal_next_node_index
                self.optimal_next_node_index = node_visit_queue[self.i]
                self.waypoints = self.global_planner(
                    self.current_node_index,
                    self.optimal_next_node_index,
                    map_id
                )
                self.tmp_target_position = self.waypoints[self.current_waypoint_index]
                self.i += 1
            
            if self.is_target_reached(current_robot_position, self.tmp_target_position) and self.current_waypoint_index < len(self.waypoints) - 1:
                self.current_waypoint_index += 1
                self.tmp_target_position = self.waypoints[self.current_waypoint_index]

            linear_velocity, angular_velocity = self.go_to_goal_controller.go_to_goal_controller(
                current_robot_pose,
                self.tmp_target_position
            )

            action = (0, linear_velocity, angular_velocity)

        return action

class Agent:
    def __init__(self, logger):
        self.logger = logger
        self.steps = 0

    def initialize_map(self, map_info: MapInfo):
        """
           
         (episode)   

        MapInfo:    
        ---
        height: int,   (  )
        width: int,   (  )
        wall_grid: np.ndarray,      2 
        room_grid: np.ndarray,        2 
        num_rooms: int,  
        grid_size: float,   (m)
        grid_origin: (float, float),  world origin wall_grid    
        station_pos: (float, float),       world 
        room_names: list of str,   
        pollution_end_time: float,     
        starting_pos: (float, float),     world 
        starting_angle: float,      (x ,  )

        is_wall: (x, y) -> bool,      
        get_room_id: (x, y) -> int,     ID   (   -1 )
        get_cells_in_room: (room_id) -> list of (x, y),        
        grid2pos: (grid) -> (x, y),    world   
        pos2grid: (pos) -> (grid_x, grid_y),  world     
        ---
        """
        # Constant
        self.resolution = 0.01

        # Identify and initialize map
        self.map = Map()        
        if map_info.num_rooms == 2: 
            self.map_id = 0
            self.map_room_num = 2
            self.map_origin = (-14 * 0.2, -20 * 0.2)
            self.pollution_end_time = 20
            map = OCCUPANCY_GRID_MAP0
        elif map_info.num_rooms == 5: 
            self.map_id = 1
            self.map_room_num = 5
            self.map_origin = (-25 * 0.2, -25 * 0.2)
            self.pollution_end_time = 80
            map = OCCUPANCY_GRID_MAP1
        elif map_info.num_rooms == 8:
            self.map_id = 2
            self.map_room_num = 8
            self.map_origin = (-37 * 0.2, -37 * 0.2)
            self.pollution_end_time = 130
            map = OCCUPANCY_GRID_MAP2
        elif map_info.num_rooms== 13:
            self.map_id = 3
            self.map_room_num = 13
            self.map_origin = (-40 * 0.2, -50 * 0.2)
            self.pollution_end_time = 200
            map = OCCUPANCY_GRID_MAP3

        # Finite state machine
        self.current_fsm_state = "READY"

        # [Localization] Initialize robot pose by IMU sensor data
        initial_robot_pose = Pose(
            _x=map_info.starting_pos[0],
            _y=map_info.starting_pos[1],
            _yaw=map_info.starting_angle
        )
        self.autonomous_navigator = AutonomousNavigator(initial_robot_pose)

        # [Localization] Occupancy grid map and distance map
        original_map = self.map.string_to_np_array_map(map)
        self.occupancy_grid_map = self.map.upscale_occupancy_grid_map(
            original_map, 
            0.2 / self.resolution
        )
        self.distance_map = self.map.occupancy_grid_to_distance_map(
            self.occupancy_grid_map, 
            map_resolution=self.resolution
        )
    
        # True robot pose in only train
        self.true_robot_pose = (None, None, None)

        # Log for debugging
        self.distance_error_sum = 0

    def act(self, observation: Observation):
        """
        env Observation  action  
         step 

        Observation:      dict
        ---
        sensor_lidar_front: np.ndarray,   (241 x 1)
        sensor_lidar_back: np.ndarray,   (241 x 1)
        sensor_tof_left: np.ndarray,  multi-tof (8 x 8)
        sensor_tof_right: np.ndarray,  multi-tof (8 x 8)
        sensor_camera: np.ndarray,   (480 x 640 x 3)
        sensor_ray: float,  1D 
        sensor_pollution: float,    
        air_sensor_pollution: np.ndarray,    (  x 1)
        disp_position: (float, float),  step    ( )
        disp_angle: float,  step    ( )
        ---

        action: (MODE, LINEAR, ANGULAR)
        MODE 0 :  , Twist  (LINEAR)  (ANGULAR) .  1m/s, 2rad/s
        MODE 1 :  ,   . LINEAR, ANGULAR .     1    
        """
        # Observation
        air_pollution_sensor_data = observation['air_sensor_pollution'] # pollution data
        robot_pollution_sensor_data =  observation['sensor_pollution']
        delta_distance = np.linalg.norm(observation["disp_position"])   # IMU data
        delta_yaw = observation['disp_angle']
        scan_ranges = observation['sensor_lidar_front']                 # LiDAR data

        # Localization
        # current_robot_pose = self.autonomous_navigator.localizer(
        #     delta_distance, 
        #     delta_yaw, 
        #     scan_ranges, 
        #     self.occupancy_grid_map, 
        #     self.distance_map, 
        #     self.map_origin, 
        #     self.resolution
        # )
        # test
        current_robot_pose = self.true_robot_pose

        # Current time
        dt = 0.1
        current_time = self.steps * dt

        # Finite state machine
        next_state, action = self.autonomous_navigator.finite_state_machine(
            air_pollution_sensor_data=air_pollution_sensor_data,
            robot_pollution_sensor_data=robot_pollution_sensor_data,
            scan_ranges=scan_ranges,
            current_time=current_time,
            pollution_end_time=self.pollution_end_time,
            current_robot_pose=current_robot_pose,
            current_fsm_state=self.current_fsm_state,
            map_id=self.map_id,
            room_num=self.map_room_num
        )
        self.current_fsm_state = next_state 

        # Log
        is_log = True
        if is_log:
            if self.true_robot_pose[0] != None or self.true_robot_pose[1] != None: # Train
                x_error = current_robot_pose[0] - self.true_robot_pose[0]
                y_error = current_robot_pose[1] - self.true_robot_pose[1]
                distance_error = math.hypot(x_error, y_error)
                self.distance_error_sum += distance_error

                if self.current_fsm_state == "NAVIGATING":
                    self.log(f"| {current_time:.1f} | {self.autonomous_navigator.visited_regions} [NAVIGATING] {self.autonomous_navigator.current_node_index} -> {self.autonomous_navigator.optimal_next_node_index} | Loc. Error: {distance_error:.3f}, Avg Loc. Error: {self.distance_error_sum / self.steps :.3f}")
                elif self.current_fsm_state == "CLEANING":
                    node_idx = self.autonomous_navigator.current_node_index
                    sensor_value = air_pollution_sensor_data[node_idx]
                    
                    if math.isnan(sensor_value):
                        sensor_value = robot_pollution_sensor_data

                    self.log(f"| {current_time:.1f} | {self.autonomous_navigator.visited_regions} [CLEANING] {node_idx}: {sensor_value:.3f} | Loc. Error: {distance_error:.3f}, Avg Loc. Error: {self.distance_error_sum / self.steps :.3f}")
                else:
                    self.log(f"| {current_time:.1f} | {self.autonomous_navigator.visited_regions} [{self.current_fsm_state}] | Loc. Error: {distance_error:.3f}, Avg Loc. Error: {self.distance_error_sum / self.steps :.3f}")
            else: # Test
                if self.current_fsm_state == "NAVIGATING":
                    self.log(f"| {current_time:.1f} | {self.autonomous_navigator.visited_regions} [NAVIGATING] {self.autonomous_navigator.current_node_index} -> {self.autonomous_navigator.optimal_next_node_index}")
                elif self.current_fsm_state == "CLEANING":
                    node_idx = self.autonomous_navigator.current_node_index
                    sensor_value = air_pollution_sensor_data[node_idx]
                    
                    if math.isnan(sensor_value):
                        sensor_value = robot_pollution_sensor_data

                    self.log(f"| {current_time:.1f} | {self.autonomous_navigator.visited_regions} [CLEANING] {node_idx}: {sensor_value:.3f}")

                else:
                    self.log(f"| {current_time:.1f}] | {self.autonomous_navigator.visited_regions} [{self.current_fsm_state}]")
        
        self.log(self.autonomous_navigator.abc)

        # --------------------------------------------------
        # For making reference waypoints -------------------
        # --------------------------------------------------
        # node_visit_queue = [8, 13]
        # action = self.autonomous_navigator.move_along_nodes(
        #     current_robot_pose, 
        #     node_visit_queue, 
        #     self.map_id,
        #     self.map_room_num
        # )
        # --------------------------------------------------

        self.steps += 1 
        return action

    def learn(
            self,
            observation: Observation,
            info: Info,
            action,
            next_observation: Observation,
            next_info: Info,
            terminated,
            done,
            ):
        """
              
        training   step (act  ), test   
         (0.7m/s   )    terminated true  ()
             done true 

        Info:          -  training 
        ---
        robot_position: (float, float),   world 
        robot_angle: float,   
        collided: bool,      
        all_pollution: np.ndarray,        
        ---
        """
        # Only simulation
        self.true_robot_pose = (info["robot_position"][0], info["robot_position"][1], info["robot_angle"])

    def reset(self):
        """
            
        training,  episode    (initialize_map  )
        """
        self.steps = 0

    def log(self, msg):
        """
          . print   .
        ROS Node logger .
        """
        self.logger(str(msg))

# Testing --------------------------------------------------
class ModelPredictivePathIntegralController:
    def __init__(self,
            state_dimension: int = 3,
            control_dimension: int = 2,

            prediction_horizon: int = 20,
            control_period: float = 0.1,

            sample_num: int = 3000,
            max_control_inputs: np.ndarray = np.array([1.0, 2.0]),
            min_control_inputs: np.ndarray = np.array([0.0, -2.0]),
            non_biased_sampling_rate: float = 0.1,
            collision_cost_weight: float = 1.0,

            softmax_lambda: float = 0.3,
        ):
        self.state_dimension = state_dimension
        self.control_dimension = control_dimension
        self.prediction_horizon = prediction_horizon
        self.control_period = control_period
        self.sample_num = sample_num
        self.max_control_inputs = max_control_inputs
        self.min_control_inputs = min_control_inputs
        self.non_biased_sampling_rate = non_biased_sampling_rate
    
        self.collision_cost_weight = collision_cost_weight
        self.softmax_lambda = softmax_lambda

        # solve
        self.previous_control_sequence = np.zeros((self.prediction_horizon - 1, self.control_dimension))

    def sample_control_sequence(self,
            control_sequence_mean: np.ndarray,
            control_sequence_covariance_matrices: np.ndarray
        ):
        num_biased = int((1 - self.non_biased_sampling_rate) * self.sample_num)

        noise = np.random.multivariate_normal(
            mean=np.zeros(self.control_dimension),
            cov=control_sequence_covariance_matrices,
            size=(self.sample_num, self.prediction_horizon - 1)
        )

        noised_control_sequences = np.zeros_like(noise)
        noised_control_sequences[:num_biased] = control_sequence_mean + noise[:num_biased]
        noised_control_sequences[num_biased:] = noise[num_biased:]

        noised_control_sequences = np.clip(
            noised_control_sequences,
            self.min_control_inputs,
            self.max_control_inputs
        )

        return noised_control_sequences
    
    def predict_state_sequence(self,
            current_state: np.ndarray,
            control_sequence: np.ndarray
        ) -> tuple[np.ndarray, np.ndarray]:
        # Declare state sequence
        global_state_sequence = np.zeros((self.prediction_horizon, 3))
        local_state_sequence = np.zeros((self.prediction_horizon, 3))

        # Set initial state
        global_state_sequence[0] = current_state
        local_state_sequence[0] = [0.0, 0.0, 0.0]

        for i in range(self.prediction_horizon - 1):
            noisy_linear_velocity, noisy_angular_velocity = control_sequence[i]

            # Update global state
            global_x, global_y, global_yaw = global_state_sequence[i]
            delta_global_x = noisy_linear_velocity * np.cos(global_yaw + noisy_angular_velocity * self.control_period / 2) * self.control_period
            delta_global_y = noisy_linear_velocity * np.sin(global_yaw + noisy_angular_velocity * self.control_period / 2) * self.control_period
            delta_global_yaw = noisy_angular_velocity * self.control_period

            global_state_sequence[i + 1] = [
                global_x + delta_global_x, 
                global_y + delta_global_y, 
                (global_yaw + delta_global_yaw + np.pi) % (2 * np.pi) - np.pi
            ]

            # Update local state
            local_x, local_y, local_yaw = local_state_sequence[i]
            delta_local_x = noisy_linear_velocity * np.cos(local_yaw + noisy_angular_velocity * self.control_period / 2) * self.control_period
            delta_local_y = noisy_linear_velocity * np.sin(local_yaw  + noisy_angular_velocity * self.control_period / 2) * self.control_period
            delta_local_yaw = noisy_angular_velocity * self.control_period

            local_state_sequence[i + 1] = [
                local_x + delta_local_x, 
                local_y + delta_local_y, 
                (local_yaw + delta_local_yaw + np.pi) % (2 * np.pi) - np.pi
            ]

        return global_state_sequence, local_state_sequence
    
    def calculate_state_sequence_cost(self,
            global_state_sequence: np.ndarray,
            local_state_sequence: np.ndarray,
            target_position: tuple[float, float],
            local_costmap: np.ndarray
        ) -> float:
        total_cost = 0

        target_x, target_y = target_position
        for i in range(self.prediction_horizon):
            global_x, global_y, global_yaw = global_state_sequence[i]
            target_yaw = np.arctan2(target_y - global_y, target_x - global_x)
            difference_yaw = target_yaw - global_yaw
            difference_yaw = (difference_yaw + np.pi) % (2 * np.pi) - np.pi

            difference_x = global_x - target_x
            difference_y = global_y - target_y

            cost = 100 * (difference_x**2 + difference_y**2) + 0.0001 * difference_yaw**2

            # test
            #     
            state_x, state_y, _ = local_state_sequence[i]
            state_x_index = int(state_x / 0.02)  #   
            state_y_index = int(state_y / 0.02)

            #    ( costmap   )
            if 0 <= state_x_index < local_costmap.shape[0] and 0 <= state_y_index < local_costmap.shape[1]:
                if local_costmap[state_x_index, state_y_index] == 100:  # max_cost   
                    #     
                    cost += 50  #      

            total_cost += cost

        return total_cost
    
    def calculate_sample_cost(self,
            control_sequence: np.ndarray,
            control_cost_matrix: np.ndarray = np.diag([1, 0.0001]),
            lambda_: float = 0.001   
        )->float:
        cost = lambda_ *np.sum((control_sequence @ control_cost_matrix) * control_sequence)
        
        return cost
            
    def softmax(self, 
            costs 
        ):
        min_cost = np.min(costs) 
        normalizing_constant = np.sum(np.exp(-(costs - min_cost) / self.softmax_lambda)) + 1e-10
        softmax_costs = np.exp(-(costs - min_cost) / self.softmax_lambda) / normalizing_constant

        return softmax_costs

    def solve(self, 
            current_state, 
            target_position,
            local_costmap
        ):
        # Sample control sequences
        noised_control_sequences = self.sample_control_sequence(
            control_sequence_mean=self.previous_control_sequence,
            control_sequence_covariance_matrices= 0.01 * np.identity(self.control_dimension)
        )

        # Evaluate costs for each sample
        costs = np.zeros(self.sample_num)
        control_costs = np.zeros(self.sample_num)
        for i in range(self.sample_num):
            global_state_sequence, local_state_sequence = self.predict_state_sequence(
                current_state=current_state, 
                control_sequence=noised_control_sequences[i]
            )

            costs[i] = self.calculate_state_sequence_cost(
                global_state_sequence=global_state_sequence, 
                local_state_sequence=local_state_sequence, 
                target_position=target_position, 
                local_costmap=local_costmap
            )

            control_costs[i] = self.calculate_sample_cost(
                control_sequence=noised_control_sequences[i]
            )

        softmax_weights = self.softmax(costs + control_costs)

        optimal_control_sequence = np.sum(softmax_weights[:, np.newaxis, np.newaxis] * noised_control_sequences, axis=0)

        # For biased random sampling
        self.previous_control_sequence = optimal_control_sequence

        return optimal_control_sequence



class ScanProcessor:
    def __init__(self,
            scan_point_num=241,
            scan_min_range=0.05,                 # (m)
            scan_max_range=8,                    # (m)
            scan_min_angle=-1.9,                 # (rad)
            scan_angle_increment=0.016,          # (rad)

            baselink_to_front=0.25,              # (m)
            baselink_to_rear=0.25,               # (m)
            baselink_to_right=0.25,              # (m)
            baselink_to_left=0.25,               # (m)
            baselink_to_laser=[0.147, 0.0, 0.0]  # [x (m), y (m), yaw (rad)]
        ):
        # Constants
        self.baselink_to_front = baselink_to_front
        self.baselink_to_rear = baselink_to_rear
        self.baselink_to_right = baselink_to_right
        self.baselink_to_left = baselink_to_left
        self.baselink_to_laser = baselink_to_laser
        self.scan_point_num = scan_point_num
        self.scan_min_range = scan_min_range
        self.scan_max_range = scan_max_range
        self.scan_min_angle = scan_min_angle
        self.scan_angle_increment = scan_angle_increment

    def convert_scan_to_pointclouds(self,
            scan_ranges: np.ndarray
        )->np.ndarray:
        """
        angle, measurement -> x, y

        Parameter
        ---------
        - scan_distance

        Using
        -----
        - self.scan_point_num
        - self.scan_min_angle
        - self.scan_angle_increment
        """
        scan_angles = self.scan_min_angle + np.arange(self.scan_point_num) * self.scan_angle_increment

        pointcloud_xs = scan_ranges * np.cos(scan_angles)
        pointcloud_ys = scan_ranges * np.sin(scan_angles)

        pointclouds = np.vstack((pointcloud_xs, pointcloud_ys)).T
        
        return pointclouds

    def preprocess_pointclouds(self,
            pointclouds: np.ndarray
        )->np.ndarray: 
        """
        Parameters
        ----------
        - pointcloud

        Using
        -----
        - self.scan_min_range
        - self.scan_max_range
        """
        # remove too near or too far points
        distances = np.linalg.norm(pointclouds[:, :2], axis=1)

        is_in_range = (distances >= self.scan_min_range) & (distances <= self.scan_max_range)
        return pointclouds[is_in_range]

    def transform_laser_to_robot_frame(self,
            pointclouds: np.ndarray
        )->np.ndarray: 
        """
        Parameter
        ---------
        - pointclouds

        Return
        ------
        np.ndarray of shape (N, 2)
            Points transformed to the robot frame.

        Using
        -----
        - self.baselink_to_laser
        """
        # Laser pose relative to robot frame
        laser_x, laser_y, laser_theta = self.baselink_to_laser

        # Rotation matrix
        cos_theta, sin_theta = np.cos(laser_theta), np.sin(laser_theta)
        rotation_matrix = np.array([[cos_theta, -sin_theta],
                                    [sin_theta,  cos_theta]])

        # Apply rotation and translation
        transformed_pointclouds = pointclouds @ rotation_matrix.T + np.array([laser_x, laser_y])

        return transformed_pointclouds

    def remove_points_within_robot(self,
            pointclouds: np.ndarray
        )->np.ndarray: 
        """
        robot frame coordinate
        X axis: forward
        Y axis: left

        Parameter
        ---------
        - pointcloud

        Using
        -----
        - self.baselink_to_rear
        - self.baselink_to_front
        - self.baselink_to_right
        - self.baselink_to_left
        """
        min_x = - self.baselink_to_rear
        max_x = self.baselink_to_front
        min_y = - self.baselink_to_right
        max_y = self.baselink_to_left

        is_inside_box = (
            (pointclouds[:, 0] >= min_x) & (pointclouds[:, 0] <= max_x) &
            (pointclouds[:, 1] >= min_y) & (pointclouds[:, 1] <= max_y)
        )

        return pointclouds[~is_inside_box]
    
    def update(self,
            scan_ranges: np.ndarray
        )->np.ndarray:
        pointcloud = self.convert_scan_to_pointclouds(scan_ranges)
        preprocessed_pointcloud = self.preprocess_pointclouds(pointcloud)
        no_robot_pointcloud = self.transform_laser_to_robot_frame(preprocessed_pointcloud)
        processed_pointcloud = self.remove_points_within_robot(no_robot_pointcloud)

        return processed_pointcloud

class LocalCostMapGenerator:
    def __init__(self,
            map_x_length: int = 16,                     # (m)
            map_y_length: int = 16,                     # (m)
            map_center_x_offset: int = 0,               # (m)
            map_center_y_offset: int = 0,               # (m)
            map_resolution: float = 0.02,               # (m)
            max_cost: int = 100
        )->None:
        # Constants
        self.map_x_length = map_x_length
        self.map_y_length = map_y_length
        self.map_center_x_offset = map_center_x_offset
        self.map_center_y_offset = map_center_y_offset
        self.map_resolution = map_resolution
        self.max_cost = max_cost

        # ScanProcessor Object
        self.scan_processor = ScanProcessor()
        self.baselink_to_front = self.scan_processor.baselink_to_front
        self.baselink_to_rear = self.scan_processor.baselink_to_rear
        self.baselink_to_right = self.scan_processor.baselink_to_right
        self.baselink_to_left = self.scan_processor.baselink_to_left
        self.baselink_to_laser = self.scan_processor.baselink_to_laser

    def convert_pointcloud_to_costmap(self,
            pointclouds: np.ndarray    
        ):
        """
        Parameter
        ---------
        - pointcloud

        Returns
        -------
        - costmap
        - occupied_indices

        Using
        -----
        - self.map_x_length
        - self.map_y_length
        - self.map_center_x_offset 
        - self.map_center_y_offset
        - self.map_resolution 
        - self.max_cost 
        """
        # Map dimensions in pixels
        height = int(self.map_x_length / self.map_resolution)
        width  = int(self.map_y_length / self.map_resolution)

        # Initialize empty costmap
        costmap = np.zeros((height, width), dtype=np.float32)

        # Convert pointcloud coordinates to map indices
        col_indices = ((pointclouds[:, 0] + 8) / self.map_resolution).astype(int)
        row_indices = ((pointclouds[:, 1] + 8) / self.map_resolution).astype(int)

        # Keep only points inside the map
        valid_mask = (row_indices >= 0) & (row_indices < height) & \
                    (col_indices >= 0) & (col_indices < width)
        row_indices = row_indices[valid_mask]
        col_indices = col_indices[valid_mask]

        # Fill costmap
        costmap[row_indices, col_indices] = self.max_cost

        # Save occupied indices
        occupied_indices = list(set(zip(row_indices, col_indices)))

        return costmap, occupied_indices

    def inflate_rigid_body(self,
            costmap: np.ndarray,
            occupied_indices: list    
        ):
        """
        Parameters
        ----------
        - costmap
        - occupied_indices

        Return
        - costmap

        Using
        -----
        - self.map_resolution
        - self.max_cost
        - self.baselink_to_front
        - self.baselink_to_rear
        - self.baselink_to_right
        - self.baselink_to_left
        """
        # Offsets (robot half-dimensions in grid cells)
        front_offset = int(np.ceil(self.baselink_to_front / self.map_resolution))
        rear_offset  = int(np.ceil(self.baselink_to_rear  / self.map_resolution))
        right_offset = int(np.ceil(self.baselink_to_right / self.map_resolution))
        left_offset  = int(np.ceil(self.baselink_to_left  / self.map_resolution))

        map_height, map_width = costmap.shape

        for row, col in occupied_indices:
            # Compute inflation bounds (clamped to map size)
            row_start = max(row - right_offset, 0)
            row_end   = min(row + left_offset + 1, map_height)

            col_start = max(col - rear_offset, 0)
            col_end   = min(col + front_offset + 1, map_width)

            # Inflate costmap region
            costmap[row_start:row_end, col_start:col_end] = self.max_cost

        return costmap

    def generate_costmap(self,
            scan_ranges: np.ndarray
        )->np.ndarray:

        pointcloud = self.scan_processor.update(
            scan_ranges=scan_ranges
        )
        
        costmap, occupied_indices = self.convert_pointcloud_to_costmap(pointcloud)
        costmap = self.inflate_rigid_body(costmap.copy(), occupied_indices)

        return costmap

import time
class DynamicObstacleTracker:
    def __init__(self,
            clustering_threshold: float = 0.3,                  # (m)
            min_cluster_size: int = 4,
            adaptive_lambda_rad: float = 20 * math.pi / 180,    # (rad)
            adaptive_sigma: float = 0.01,

            velocity_threshold: float = 1.0,                    # (m/s)  
            association_threshold: float = 1.0,                 # (m)
            max_cluster_points: int = 100,                      #    
            rotation_sensitivity_gain: float = 1.0,
            
            dt: float = 0.1                                     # (s)
        ):
        # Constants
        self.clustering_threshold = clustering_threshold
        self.min_cluster_size = min_cluster_size
        self.adaptive_lambda_rad = adaptive_lambda_rad
        self.adaptive_sigma = adaptive_sigma
        self.velocity_threshold = velocity_threshold
        self.association_threshold = association_threshold
        self.max_cluster_points = max_cluster_points
        self.rotation_sensitivity_gain = rotation_sensitivity_gain
        self.dt = dt

        # ScanProcessor Object
        self.scan_processor = ScanProcessor()
        self.scan_angle_increment = self.scan_processor.scan_angle_increment=0.016     # (rad)

        # [Function] update
        self.previous_centers_map = np.array([])
        self.last_update_time = None

    def transform_robot_to_map_frame(self,
            pointclouds_robot: np.ndarray,
            current_robot_pose: tuple
        ) -> np.ndarray:
        current_robot_x_map, current_robot_y_map, current_robot_yaw_map = current_robot_pose

        cos_yaw_map = np.cos(current_robot_yaw_map)
        sin_yaw_map = np.sin(current_robot_yaw_map)
        rotation_matrix = np.array([
            [cos_yaw_map, -sin_yaw_map],
            [sin_yaw_map, cos_yaw_map]
        ])
        rotated_pointclouds = pointclouds_robot @ rotation_matrix.T
        pointclouds_map = rotated_pointclouds + np.array([
            current_robot_x_map, current_robot_y_map
        ])

        return pointclouds_map

    def extract_clusters(self, 
            pointcloud: np.ndarray
        ) -> list[np.ndarray]:
        """

        """
        if pointcloud.shape[0] < 2:
            return [pointcloud] if pointcloud.shape[0] > 0 else []

        # Distances
        deltas = np.diff(pointcloud, axis=0)
        distances_between_points = np.linalg.norm(deltas, axis=1)

        # Distance from origin
        distances_from_origin = np.linalg.norm(pointcloud, axis=1)
        
        #           
        relevant_dists = np.minimum(distances_from_origin[:-1], distances_from_origin[1:])
        
        sin_lambda_minus_dphi = math.sin(self.adaptive_lambda_rad - self.scan_angle_increment)
        if abs(sin_lambda_minus_dphi) < 1e-9:
             sin_lambda_minus_dphi = 1e-9

        adaptive_thresholds = (relevant_dists * math.sin(self.scan_angle_increment) / sin_lambda_minus_dphi + self.adaptive_sigma)
        
        #           
        # (   ,     )
        final_thresholds = np.maximum(self.clustering_threshold, adaptive_thresholds)

        # 3.   (breakpoint)  
        breakpoint_indices = np.where(distances_between_points > final_thresholds)[0]

        # 4. breakpoint     
        clusters = np.split(pointcloud, breakpoint_indices + 1)

        clusters = [c for c in clusters if c.shape[0] >= self.min_cluster_size]
        
        return clusters
    
    def update(self,
            scan_ranges: np.ndarray,
            current_robot_pose: tuple
        ) -> bool:
        
        # --- 1.      ---
        current_time = time.time()
        if self.last_update_time is None or self.previous_pose is None:
            self.last_update_time = current_time
            self.previous_pose = current_robot_pose
            
            #     
            initial_pc_robot = self.scan_processor.update(scan_ranges)
            initial_clusters = self.extract_clusters(initial_pc_robot)
            initial_centers = np.array([np.mean(c, axis=0) for c in initial_clusters])
            if initial_centers.size > 0:
                self.previous_centers_map = self.transform_robot_to_map_frame(initial_centers, current_robot_pose)
            return False
        
        dt = current_time - self.last_update_time
        self.last_update_time = current_time
        if dt < 1e-6:
            return False

        # --- 2. (Detection): ScanProcessor     ---
        # [] ScanProcessor update   (,  )  
        pc_robot = self.scan_processor.update(scan_ranges)
        
        clusters_robot = self.extract_clusters(pc_robot)
        clusters_robot = [c for c in clusters_robot if len(c) < self.max_cluster_points]

        if not clusters_robot:
            self.previous_centers_map = np.array([])
            self.previous_pose = current_robot_pose
            return False

        current_centers_map = self.transform_robot_to_map_frame(
            np.array([np.mean(c, axis=0) for c in clusters_robot]),
            current_robot_pose
        )

        # --- 3. (Tracking)  (Classification) ---
        # []         
        delta_yaw = current_robot_pose[2] - self.previous_pose[2]
        delta_yaw = math.atan2(math.sin(delta_yaw), math.cos(delta_yaw))
        rotational_velocity = abs(delta_yaw) / dt
        adaptive_v_thresh = self.velocity_threshold + self.rotation_sensitivity_gain * rotational_velocity

        dynamic_detected = False
        if len(self.previous_centers_map) > 0:
            for cc_map in current_centers_map:
                distances = np.linalg.norm(self.previous_centers_map - cc_map, axis=1)
                if len(distances) == 0: continue
                min_dist = np.min(distances)

                if min_dist > self.association_threshold:
                    continue

                velocity = min_dist / dt
                if velocity > adaptive_v_thresh:
                    dynamic_detected = True
                    break
        
        # --- 4.   ---
        self.previous_centers_map = current_centers_map
        self.previous_pose = current_robot_pose
        
        return dynamic_detected